I have a tuple of tuples from a MySQL query like this:I\'d like to convert all the string elements into integers and put them back into a list of lists:I tried to achieve it with eval but didn\'t get any decent result yet.int() is the Python standard built-in function to convert a string into an integer value. You call it with a string containing a number as the argument, and it returns the number converted to an actual integer:The above prints 2.If you know the structure of your list (that it simply contains lists, only one level), you could do this in python 2:In python 3:You can do this with a list comprehension:The inner list comprehension ([int(column) for column in row]) builds a list of ints from a sequence of int-able objects, like decimal strings, in row. The outer list comprehension ([... for row in T1])) builds a list of the results of the inner list comprehension applied to each item in T1.The code snippet will fail if any of the rows contain objects that can\'t be converted by int. You\'ll need a smarter function if you want to process rows containing non-decimal strings.If you know the structure of the rows, you can replace the inner list comprehension with a call to a function of the row. Eg.I would rather prefer using only comprehension lists:Instead of putting int( ), put float( ) which will let you use decimals along with integers.I would agree with everyones answers so far but the problem is is that if you do not have all integers they will crash.If you wanted to exclude non-integers thenThis yields only actual digits.  The reason I don\'t use direct list comprehensions is because list comprehension leaks their internal variables.Try this.x is a string because it has quotes around it, but it has a number in it.Since x has the number 1 in it, I can turn it in to a integer.To see if a string is a number, you can do this.It should print to IDLE True because x is a number.It should print to IDLE False because y in not a number.Using list comprehensions:Yet another functional solution for Python 2:Python 3 will be a little bit messy though:If it\'s only a tuple of tuples, something like rows=[map(int, row) for row in rows] will do the trick. (There\'s a list comprehension and a call to map(f, lst), which is equal to [f(a) for a in lst], in there.)Eval is not what you want to do, in case there\'s something like __import__("os").unlink("importantsystemfile") in your database for some reason.\nAlways validate your input (if with nothing else, the exception int() will raise if you have bad input).In Python 3.5.1 things like these work:andGeorge.please notice:when using map, you will get a list of map objects in python 3 and 3.5. This does it for Python 3.5 as mentioned above.See this functionThenYou can also checkmaybe that;ll work