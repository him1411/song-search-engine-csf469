Apparently, the following is valid syntax...I would like to know...I found a related question right here on SO but that question is about PHP though and it states the b is used to indicate the string is binary as opposed to unicode which was needed for code to be compatible from version of PHP < 6 when migrating to PHP 6. I don\'t think this applies to Python.I did find this documentation on the python site about using a u character in the same syntax to specify a string as unicode. Unfortunately it doesn\'t mention the b character anywhere in that document.Also, just out of curiosity, are there more symbols than the b and u that do other things?To quote the Python 2.x documentation:A prefix of \'b\' or \'B\' is ignored in\n  Python 2; it indicates that the\n  literal should become a bytes literal\n  in Python 3 (e.g. when code is\n  automatically converted with 2to3). A\n  \'u\' or \'b\' prefix may be followed by\n  an \'r\' prefix.The Python 3.3 documentation states:Bytes literals are always prefixed with \'b\' or \'B\'; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.Python 3.x makes a clear distinction between the types:If you\'re familiar with Java or C#, think of str as String and bytes as byte[].  If you\'re familiar with SQL, think of str as NVARCHAR and bytes as BINARY or BLOB.  If you\'re familiar with the Windows registry, think of str as REG_SZ and bytes as REG_BINARY.  If you\'re familiar with C(++), then forget everything you\'ve learned about char and strings, because A CHARACTER IS NOT A BYTE.  That idea is long obsolete.You use str when you want to represent text.You use bytes when you want to represent low-level binary data like structs.You can encode a str to a bytes object.And you can decode a bytes into a str.But you can\'t freely mix the two types.The b\'...\' notation is somewhat confusing in that it allows the bytes 0x01-0x7F to be specified with ASCII characters instead of hex numbers.But I must emphasize, a character is not a byte.Pre-3.0 versions of Python lacked this kind of distinction between text and binary data.  Instead, there was:In order to ease the 2.x-to-3.x transition, the b\'...\' literal syntax was backported to Python 2.6, in order to allow distinguishing binary strings (which should be bytes in 3.x) from text strings (which should be str in 3.x).  The b prefix does nothing in 2.x, but tells the 2to3 script not to convert it to a Unicode string in 3.x.So yes, b\'...\' literals in Python have the same purpose that they do in PHP.Also, just out of curiosity, are there\n  more symbols than the b and u that do\n  other things?The r prefix creates a raw string (e.g., r\'\\t\' is a backslash + t instead of a tab), and triple quotes \'\'\'...\'\'\' or """...""" allow multi-line string literals.The b denotes a byte string.Bytes are the actual data. Strings are an abstraction.If you had multi-character string object and you took a single character, it would be a string, and it might be more than 1 byte in size depending on encoding.If took 1 byte with a byte string, you\'d get a single 8-bit value from 0-255 and it might not represent a complete character if those characters due to encoding were > 1 byte.TBH I\'d use strings unless I had some specific low level reason to use bytes.It turns it into a bytes literal (or str in 2.x), and is valid for 2.6+.The r prefix causes backslashes to be "uninterpreted" (not ignored, and the difference does matter).Here\'s an example where the absence of \'b\' would throw a TypeError exception in Python 3.xAdding a \'b\' prefix would fix the problem. 