I made a function which will look up ages in dictionary and show the matching name:I know how to compare and find the age I just don\'t know how to show the name of the person. Additionally, I am getting a KeyError because of line 5. I know it\'s not correct but I can\'t figure out to make it search backwards.There is none. dict is not intended to be used this way.Or in Python 3.x:Basically, it separates the dictionary\'s values in a list, finds the position of the value you have, and gets the key at that position.More about keys() and .values() in Python 3: Python: simplest way to get list of values from dict?If you want both the name and the age, you should be using .items() which gives you key (key, value) tuples:You can unpack the tuple into two separate variables right in the for loop, then match the age.You should also consider reversing the dictionary if you\'re generally going to be looking up by age, and no two people have the same age:so you can look up the name for an age by just doingI\'ve been calling it mydict instead of list because list is the name of a built-in type, and you shouldn\'t use that name for anything else.You can even get a list of all people with a given age in one line:or if there is only one person with each age:which will just give you None if there isn\'t anyone with that age.Finally, if the dict is long and you\'re on Python 2, you should consider using .iteritems() instead of .items() as Cat Plus Plus did in his answer, since it doesn\'t need to make a copy of the list.I thought it would be interesting to point out which methods are the quickest, and in what scenario:Here\'s some tests I ran (on a 2012 MacBook Pro)Results from profile.run() on each method 100000 times:Method 1:Method 2:Method 3:So this shows that for a small dict, method 1 is the quickest. This is most likely because it returns the first match, as opposed to all of the matches like method 2 (see note below).Interestingly, performing the same tests on a dict I have with 2700 entries, I get quite different results (this time run 10000 times):Method 1:Method 2:Method 3:So here, method 3 is much faster. Just goes to show the size of your dict will affect which method you choose.Notes:\nMethod 2 returns a list of all names, whereas methods 1 and 3 return only the first match.\nI have not considered memory usage. I\'m not sure if method 3 creates 2 extra lists (keys() and values()) and stores them in memory.one line version: (i is an old dictionary, p is a reversed dictionary)or betterHere is my take on this problem. :)\nI have just started learning Python, so I call this:"The Understandable for beginners" solution...You can get key by using dict.keys(), dict.values() and list.index() methods, see code samples below:If you want to find the key by the value, you can use a dictionary comprehension to create a lookup dictionary and then use that to find the key from the value.it\'s answered, but it could be done with a fancy \'map/reduce\' use, e.g.:There is no easy way to find a key in a list by \'looking up\' the value. However, if you know the value, iterating through the keys, you can look up values in the dictionary by the element. If D[element] where D is a dictionary object, is equal to the key you\'re trying to look up, you can execute some code.Cat Plus Plus mentioned that this isn\'t how a dictionary is intended to be used. Here\'s why:The definition of a dictionary is analogous to that of a mapping in mathematics. In this case, a dict is a mapping of K (the set of keys) to V (the values) - but not vice versa. If you dereference a dict, you expect to get exactly one value returned. But, it is perfectly legal for different keys to map onto the same value, e.g.:When you look up a key by it\'s corresponding value, you\'re essentially inverting the dictionary. But a mapping isn\'t necessarily invertible! In this example, asking for the key corresponding to v1 could yield k1 or k3. Should you return both? Just the first one found? That\'s why indexof() is undefined for dictionaries.If you know your data, you could do this. But an API can\'t assume that an arbitrary dictionary is invertible, hence the lack of such an operation.here is my take on it. This is good for displaying multiple results just in case you need one. So I added the list as well And that\'s it... Sometimes int() may be needed:You need to use a dictionary and reverse of that dictionary. It means you need another data structure. If you are in python 3, use enum module but if you are using python 2.7 use enum34 which is back ported for python 2.Example:Consider using Pandas. As stated in William McKinney\'s "Python for Data Analysis\'Another way to think about a Series is as a fixed-length, ordered\n  dict, as it is a mapping of index values to data values. It can be\n  used in many contexts where you might use a dict.To query your series do the following:Which yields:If you need to do anything else with the output transforming the \nanswer into a list might be useful:already been answered, but since several people mentioned reversing the dictionary, here\'s how you do it in one line (assuming 1:1 mapping) and some various perf data:python 2.6:2.7+:if you think it\'s not 1:1, you can still create a reasonable reverse mapping with a couple lines:how slow is this: slower than a simple search, but not nearly as slow as you\'d think - on a \'straight\' 100000 entry dictionary, a \'fast\' search (i.e. looking for a value that should be early in the keys) was about 10x faster than reversing the entire dictionary, and a \'slow\' search (towards the end) about 4-5x faster. So after at most about 10 lookups, it\'s paid for itself. the second version (with lists per item) takes about 2.5x as long as the simple version.Also had some interesting results with ifilter. Theoretically, ifilter should be faster, in that we can use itervalues() and possibly not have to create/go through the entire values list. In practice, the results were... odd...So, for small offsets, it was dramatically faster than any previous version (2.36 *u*S vs. a minimum of 1.48 *m*S for previous cases). However, for large offsets near the end of the list, it was dramatically slower (15.1ms vs. the same 1.48mS). The small savings at the low end is not worth the cost at the high end, imho. This is how you access the dictionary to do what you want:of course, your names are so off it looks like it would be printing an age, but it DOES print the name. Since you are accessing by name, it becomes more understandable if you write:Better yet: The output is as follows:Here is a solution which works both in Python 2 and Python 3:The part until [search_age] constructs the reverse dictionary (where values are keys and vice-versa).\nYou could create a helper method which will cache this reversed dictionary like so:or even more generally a factory which would create a by-age name lookup method for one or more of you listsso you would be able to do:Note that I renamed list to ages_by_name since the former is a predefined type.I know this is old but you could quite easily find all the people in the list with your search age using list comprehension.I hope this might help...A simple way to do this could be:This will return a list of the keys with value that match search_age. You can also replace "list==search_age" with any other conditions statement if needed.