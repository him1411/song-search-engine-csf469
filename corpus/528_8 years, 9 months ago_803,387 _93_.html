What is the best possible way to check if a string can be represented as a number in Python? The function I currently have right now is:Which, not only is ugly and slow, seems clunky. However I haven\'t found a better method because calling float in the main function is even worse. Which, not only is ugly and slowI\'d dispute both.A regex or other string parsing would be uglier and slower.  I\'m not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn\'t introduce much overhead because the most common exception is caught without an extensive search of stack frames.The issue is that any numeric conversion function has two kinds of resultsC (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.I think your code for doing this is perfect.In case you are looking for parsing (positive, unsigned) integers instead of floats, you can use the isdigit() function for string objects.String Methods - isdigit()There\'s also something on Unicode strings, which I\'m not too familiar with\nUnicode - Is decimal/decimalThere is one exception that you may want to take into account: the string \'NaN\'If you want is_number to return FALSE for \'NaN\' this code will not work as Python converts it to its representation of a number that is not a number (talk about identity issues):Otherwise, I should actually thank you for the piece of code I now use extensively. :)G.how about this:which will return true only if there is one or no \'.\' in the string of digits.will return falseedit: just saw another comment ...\nadding a .replace(badstuff,\'\',maxnum_badstuff) for other cases can be done. if you are passing salt and not arbitrary condiments (ref:xkcd#974) this will do fine :PWhich, not only is ugly and slow, seems clunky.It may take some getting used to, but this is the pythonic way of doing it.  As has been already pointed out, the alternatives are worse.  But there is one other advantage of doing things this way:  polymorphism.The central idea behind duck typing is that "if it walks and talks like a duck, then it\'s a duck."  What if you decide that you need to subclass string so that you can change how you determine if something can be converted into a float?  Or what if you decide to test some other object entirely?  You can do these things without having to change the above code.Other languages solve these problems by using interfaces.  I\'ll save the analysis of which solution is better for another thread.  The point, though, is that python is decidedly on the duck typing side of the equation, and you\'re probably going to have to get used to syntax like this if you plan on doing much programming in Python (but that doesn\'t mean you have to like it of course).One other thing you might want to take into consideration: Python is pretty fast in throwing and catching exceptions compared to a lot of other languages (30x faster than .Net for instance).  Heck, the language itself even throws exceptions to communicate non-exceptional, normal program conditions (every time you use a for loop).  Thus, I wouldn\'t worry too much about the performance aspects of this code until you notice a significant problem.Updated after Alfe pointed out you don\'t need to check for float separately as complex handles both:Previously said: Is some rare cases you might also need to check for complex numbers (e.g. 1+2i), which can not be represented by a float:TL;DR The best solution is s.replace(\'.\',\'\',1).isdigit()I did some benchmarks comparing the different approachesIf the string is not a number, the except-block is quite slow. But more importantly, the try-except method is the only approach that handles scientific notations correctly.Float notation ".1234" is not supported by:\n- is_number_regex  Scientific notation "1.000000e+50" is not supported by:\n- is_number_regex\n- is_number_repl_isdigit\nScientific notation "1e50" is not supported by:\n- is_number_regex\n- is_number_repl_isdigit  where the following functions were testedFor int use this:But for float we need some tricks ;-). Every float number has one point...Also for negative numbers just add lstrip():And now we get a universal way:In C# there are two different functions that handle parsing of scalar values:float.parse():Note: If you\'re wondering why I changed the exception to a TypeError, here\'s the documentation.float.try_parse():Note: You don\'t want to return the boolean \'False\' because that\'s still a value type. None is better because it indicates failure. Of course, if you want something different you can change the fail parameter to whatever you want.To extend float to include the \'parse()\' and \'try_parse()\' you\'ll need to monkeypatch the \'float\' class to add these methods.If you want respect pre-existing functions the code should be something like:SideNote: I personally prefer to call it Monkey Punching because it feels like I\'m abusing the language when I do this but YMMV.Usage:And the great Sage Pythonas said to the Holy See Sharpisus, "Anything you can do I can do better; I can do anything better than you."I know this is particularly old but I would add an answer I believe covers the information missing from the highest voted answer that could be very valuable to any who find this:For each of the following methods connect them with a count if you need any input to be accepted. (Assuming we are using vocal definitions of integers rather than 0-255, etc.)x.isdigit()\nworks well for checking if x is an integer.x.replace(\'-\',\'\').isdigit()\nworks well for checking if x is a negative.(Check - in first position)x.replace(\'.\',\'\').isdigit()\nworks well for checking if x is a decimal.x.replace(\':\',\'\').isdigit()\nworks well for checking if x is a ratio.x.replace(\'/\',\'\',1).isdigit()\nworks well for checking if x is a fraction.For strings of non-numbers, try: except: is actually slower than regular expressions.  For strings of valid numbers, regex is slower.  So, the appropriate method depends on your input. If you find that you are in a performance bind, you can use a new third-party module called fastnumbers that provides a function called isfloat.  Full disclosure, I am the author.  I have included its results in the timings below.As you can seeYou can use Unicode strings, they have a method to do just what you want:Or:http://www.tutorialspoint.com/python/string_isnumeric.htmhttp://docs.python.org/2/howto/unicode.htmlCasting to float and catching ValueError is probably the fastest way, since float() is specifically meant for just that. Anything else that requires string parsing (regex, etc) will likely be slower due to the fact that it\'s not tuned for this operation. My $0.02.Lets say you have digits in string.\nstr = "100949"\nand you would like to check if it has only numbersisdigit docsotherwise your method works great to find the occurrence of a digit in a string. So to put it all together, checking for Nan, infinity and complex numbers (it would seem they are specified with j, not i, i.e. 1+2j) it results in:Your code looks fine to me.Perhaps you think the code is "clunky" because of using exceptions?  Note that Python programmers tend to use exceptions liberally when it improves code readability, thanks to its low performance penalty.I wanted to see which method is fastest, and turns out catching an exception is the fastest.I did some speed test. Lets say that if the string is likely to be a number the try/except strategy is the fastest possible.If the string is not likely to be a number and you are interested in Integer check, it worths to do some test (isdigit plus heading \'-\'). \nIf you are interested to check float number, you have to use the try/except code whitout escape.RyanN suggestsIf you want to return False for a NaN and Inf, change line to x = float(s); return (x == x) and (x - 1 != x). This should return True for all floats except Inf and NaNBut this doesn\'t quite work, because for sufficiently large floats, x-1 == x returns true. For example, 2.0**54 - 1 == 2.0**54If you want to know if the entire string can be represented as a number you\'ll want to use a regexp (or maybe convert the float back to a string and compare it to the source string, but I\'m guessing that\'s not very fast).Here\'s my simple way of doing it. Let\'s say that I\'m looping through some strings and I want to add them to an array if they turn out to be numbers.Replace the myvar.apppend with whatever operation you want to do with the string if it turns out to be a number. The idea is to try to use a float() operation and use the returned error to determine whether or not the string is a number.I needed to determine if a string cast into basic types (float,int,str,bool). After not finding anything on the internet I created this:ExampleYou can capture the type and use it Try this.I also used the function you mentioned, but soon I notice that strings as "Nan", "Inf" and it\'s variation are considered as number. So I propose you improved version of your function, that will return false on those type of input and will not fail "1e3" variants:You can generalize the exception technique in a useful way by returning more useful values than True and False.  For example this function puts quotes round strings but leaves numbers alone.  Which is just what I needed for a quick and dirty filter to make some variable definitions for R. I was working on a problem that led me to this thread, namely how to convert a collection of data to strings and numbers in the most intuitive way.  I realized after reading the original code that what I needed was different in two ways:1 - I wanted an integer result if the string represented an integer2 - I wanted a number or a string result to stick into a data structureso I adapted the original code to produce this derivative:You may use regex.use following it handles all cases:-To check if the input value is a float, you can compare the type of the input to a floatReturns:The original post would actually return True for s = 5 since it is a number (integer) and you can cast an int to a float without a ValueError. If you are trying to verify that it is an actual float instead of just a number, you would need to account for that case.