What is the difference between iterators and generators? Some examples for when you would use each case would be helpful.iterator is a more general concept: any object whose class has a next method (__next__ in Python 3) and an __iter__ method that does return self.Every generator is an iterator, but not vice versa.  A generator is built by calling a function that has one or more yield expressions (yield statements, in Python 2.5 and earlier), and is an object that meets the previous paragraph\'s definition of an iterator.You may want to use a custom iterator, rather than a generator, when you need a class with somewhat complex state-maintaining behavior, or want to expose other methods besides next (and __iter__ and __init__).  Most often, a generator (sometimes, for sufficiently simple needs, a generator expression) is sufficient, and it\'s simpler to code because state maintenance (within reasonable limits) is basically "done for you" by the frame getting suspended and resumed.For example, a generator such as:or the equivalent generator expression (genexp)would take more code to build as a custom iterator:But, of course, with class Squares you could easily offer extra methods, i.e.if you have any actual need for such extra functionality in your application.In summary: Iterators are objects that have an __iter__ and a __next__ (next in Python 2) method. Generators provide an easy, built-in way to create instances of Iterators.A function with yield in it is still a function, that, when called, returns an instance of a generator object:A generator expression also returns a generator:For a more in-depth exposition and examples, keep reading.Specifically, generator is a subtype of iterator.We can create a generator several ways. A very common and simple way to do so is with a function. Specifically, a function with yield in it is a function, that, when called, returns a generator:And a generator, again, is an Iterator:An Iterator is an Iterable, which requires an __iter__ method that returns an Iterator:Some examples of iterables are tuples, lists, sets, dicts, strings, and range objects:In Python 2: And in Python 3:We can get the iterators from the builtin objects (or custom objects) with the iter function:The __iter__ function is what is invoked when you attempt to use an object with a for-loop. Then __next__ or next is called on the iterator object to get each item out for the loop. The iterator raises StopIteration when you have exhausted it, and it cannot be reused at that point.From the Generator Types section of the Iterator Types section of the Built-in Types documentation:Python\xe2\x80\x99s generators provide a convenient way to implement the iterator protocol. If a container object\xe2\x80\x99s __iter__() method is implemented as a generator, it will automatically return an iterator object (technically, a generator object) supplying the __iter__() and next() [__next__() in Python 3] methods. More information about generators can be found in the documentation for the yield expression.(Emphasis added.)So from this we learn that Generators are a (convenient) type of Iterator. You might create object that implements the Iterator protocol by creating or extending your own object.But it\'s easier to simply use a Generator to do this:Or perhaps simpler, a Generator Expression (works similarly to list comprehensions):They can all be used in the same way:You can use the Iterator protocol directly when you need to extend a Python object as an object that can be iterated over. However, in the vast majority of cases, you are best suited to use yield to define a function that returns a Generator or consider Generator Expressions.Finally, note that generators provide even more functionality as coroutines. I explain Generators, along with the yield statement, in depth on my answer to "What does the \xe2\x80\x9cyield\xe2\x80\x9d keyword do?".Iterators:Iterator are objects which uses next() method to get next value of sequence.Generators:A generator is a function that produces or yields a sequence of values using yield method. Every next() method call on generator object(for ex: f as in below example) returned by generator function(for ex: foo() function in below example), generates next value in sequence.When a generator function is called, it returns an generator object without even beginning execution of the function. When next() method is called for the first time, the function starts executing until it reaches yield statement which returns the yielded value. The yield keeps track of i.e. remembers last execution. And second next() call continues from previous value.The following example demonstrates the interplay between yield and call to next method on generator object.Adding an answer because none of the existing answers specifically address the confusion in the official literature.Generator functions are ordinary functions defined using yield instead of return. When called, a generator function returns a generator object, which is a kind of iterator - it has a next() method. When you call next(), the next value yielded by the generator function is returned.Either the function or the object may be called the "generator" depending on which Python source document you read. The Python glossary says generator functions, while the Python wiki implies generator objects. The Python tutorial remarkably manages to imply both usages in the space of three sentences:Generators are a simple and powerful tool for creating iterators. They are written like regular functions but use the yield statement whenever they want to return data. Each time next() is called on it, the generator resumes where it left off (it remembers all the data values and which statement was last executed). The first two sentences identify generators with generator functions, while the third sentence identifies them with generator objects.Despite all this confusion, one can seek out the Python language reference for the clear and final word:The yield expression is only used when defining a generator function, and can only be used in the body of a function definition. Using a yield expression in a function definition is sufficient to cause that definition to create a generator function instead of a normal function.When a generator function is called, it returns an iterator known as a generator. That generator then controls the execution of a generator function. So, in formal and precise usage, "generator" unqualified means generator object, not generator function. The above references are for Python 2 but Python 3 language reference says the same thing. However, the Python 3 glossary states thatgenerator ... Usually refers to a generator function, but may refer to a generator iterator in some contexts. In cases where the intended meaning isn\xe2\x80\x99t clear, using the full terms avoids ambiguity.Generator Function, Generator Object, Generator:A Generator function is just like a regular function in Python but it contains one or more yield statements. Generator functions is a great tool to create  Iterator objects as easy as possible.  The Iterator object returend by generator function is also called Generator object or Generator. In this example I have created a Generator function which returns a Generator object <generator object fib at 0x01342480>. Just like other iterators, Generator objects can be used in a  for loop  or with   the built-in function next() which returns the next value from generator. So a generator function is the easiest way to create an Iterator object.Iterator:Every generator object is an iterator but not vice versa.  A custom  iterator object  can  be created if its class implements  __iter__ and __next__ method (also called iterator protocol). However, it is  much easier to use generators function to create iterators because they simplify their creation,  but a custom Iterator gives you more freedom and you can also implement other methods according to your requirements as shown in the  below example. You can compare both approaches for the same data:Besides, if you check the memory footprint, the generator takes much less memory as it doesn\'t need to store all the values in memory at the same time.Everybody has a really nice and verbose answer with examples and I really appreciate it. I just wanted to give a short few lines answer for people who are still not quite clear conceptually:If you create your own iterator, it is a little bit involved - you have \nto create a class and at least implement the iter and the next methods. But what if you don\'t want to go through this hassle and want to quickly create an iterator. Fortunately, Python provides a short-cut way to defining an iterator. All you need to do is define a function with at least 1 call to yield and now when you call that function it will return "something" which will act like an iterator (you can call next method and use it in a for loop). This something has a name in Python called GeneratorHope that clarifies a bit.