Every so often when programmers are complaining about null errors/exceptions someone asks what we do without null.I have some basic idea of the coolness of option types, but I don\'t have the knowledge or languages skill to best express it. What is a great explanation of the following written in a way approachable to the average programmer that we could point that person towards?I think the succinct summary of why null is undesirable is that meaningless states should not be representable.Suppose I\'m modeling a door.  It can be in one of three states: open, shut but unlocked, and shut and locked.  Now I could model it along the lines ofand it is clear how to map my three states into these two boolean variables.  But this leaves a fourth, undesired state available: isShut==false && isLocked==true.  Because the types I have selected as my representation admit this state, I must expend mental effort to ensure that the class never gets into this state (perhaps by explicitly coding an invariant).  In contrast, if I were using a language with algebraic data types or checked enumerations that lets me definethen I could defineand there are no more worries.  The type system will ensure that there are only three possible states for an instance of class Door to be in.  This is what type systems are good at - explicitly ruling out a whole class of errors at compile-time.The problem with null is that every reference type gets this extra state in its space that is typically undesired.  A string variable could be any sequence of characters, or it could be this crazy extra null value that doesn\'t map into my problem domain.  A Triangle object has three Points, which themselves have X and Y values, but unfortunately the Points or the Triangle itself might be this crazy null value that is meaningless to the graphing domain I\'m working in.  Etc.When you do intend to model a possibly-non-existent value, then you should opt into it explicitly.  If the way I intend to model people is that every Person has a FirstName and a LastName, but only some people have MiddleNames, then I would like to say something likewhere string here is assumed to be a non-nullable type.  Then there are no tricky invariants to establish and no unexpected NullReferenceExceptions when trying to compute the length of someone\'s name.  The type system ensures that any code dealing with the MiddleName accounts for the possibility of it being None, whereas any code dealing with the FirstName can safely assume there is a value there.  So for example, using the type above, we could author this silly function:with no worries.  In contrast, in a language with nullable references for types like string, then assumingyou end up authoring stuff like which blows up if the incoming Person object does not have the invariant of everything being non-null, oror maybeassuming that p ensures first/last are there but middle can be null, or maybe you do checks that throw different types of exceptions, or who knows what.  All these crazy implementation choices and things to think about crop up because there\'s this stupid representable-value that you don\'t want or need.Null typically adds needless complexity.  Complexity is the enemy of all software, and you should strive to reduce complexity whenever reasonable.(Note well that there is more complexity to even these simple examples.  Even if a FirstName cannot be null, a string can represent "" (the empty string), which is probably also not a person name that we intend to model.  As such, even with non-nullable strings, it still might be the case that we are "representing meaningless values".  Again, you could choose to battle this either via invariants and conditional code at runtime, or by using the type system (e.g. to have a NonEmptyString type).  The latter is perhaps ill-advised ("good" types are often "closed" over a set of common operations, and e.g. NonEmptyString is not closed over .SubString(0,0)), but it demonstrates more points in the design space.  At the end of the day, in any given type system, there is some complexity it will be very good at getting rid of, and other complexity that is just intrinsically harder to get rid of.  The key for this topic is that in nearly every type system, the change from "nullable references by default" to "non-nullable references by default" is nearly always a simple change that makes the type system a great deal better at battling complexity and ruling out certain types of errors and meaningless states.  So it is pretty crazy that so many languages keep repeating this error again and again.)The nice thing about option types isn\'t that they\'re optional. It is that all other types aren\'t.Sometimes, we need to be able to represent a kind of "null" state. Sometimes we have to represent a "no value" option as well as the other possible values a variable may take. So a language that flat out disallows this is going to be a bit crippled.But often, we don\'t need it, and allowing such a "null" state only leads to ambiguity and confusion: every time I access a reference type variable in .NET, I have to consider that it might be null.Often, it will never actually be null, because the programmer structures the code so that it can never happen. But the compiler can\'t verify that, and every single time you see it, you have to ask yourself "can this be null? Do I need to check for null here?"Ideally, in the many cases where null doesn\'t make sense, it shouldn\'t be allowed.That\'s tricky to achieve in .NET, where nearly everything can be null. You have to rely on the author of the code you\'re calling to be 100% disciplined and consistent and have clearly documented what can and cannot be null, or you have to be paranoid and check everything.However, if types aren\'t nullable by default, then you don\'t need to check whether or not they\'re null. You know they can never be null, because the compiler/type checker enforces that for you.And then we just need a back door for the rare cases where we do need to handle a null state. Then an "option" type can be used. Then we allow null in the cases where we\'ve made a conscious decision that we need to be able to represent the "no value" case, and in every other case, we know that the value will never be null.As others have mentioned, in C# or Java for example, null can mean one of two things:The second meaning has to be preserved, but the first one should be eliminated entirely. And even the second meaning should not be the default. It\'s something we can opt in to if and when we need it. But when we don\'t need something to be optional, we want the type checker to guarantee that it will never be null.All of the answers so far focus on why null is a bad thing, and how it\'s kinda handy if a language can guarantee that certain values will never be null.They then go on to suggest that it would be a pretty neat idea if you enforce non-nullability for all values, which can be done if you add a concept like Option or Maybe to represent types that may not always have a defined value.  This is the approach taken by Haskell.It\'s all good stuff!  But it doesn\'t preclude the use of explicitly nullable / non-null types to achieve the same effect.  Why, then, is Option still a good thing?  After all, Scala supports nullable values (is has to, so it can work with Java libraries) but supports Options as well.Q. So what are the benefits beyond being able to remove nulls from a language entirely?A. CompositionIf you make a naive translation from null-aware codeto option-aware codethere\'s not much difference!  But it\'s also a terrible way to use Options...  This approach is much cleaner:Or even:When you start dealing with List of Options, it gets even better.  Imagine that the List people is itself optional:How does this work?The corresponding code with null checks (or even elvis ?: operators) would be painfully long.  The real trick here is the flatMap operation, which allows for the nested comprehension of Options and collections in a way that nullable values can never achieve.Since people seem to be missing it: null is ambiguous.Alice\'s date-of-birth is null. What does it mean?Bob\'s date-of-death is null. What does that mean?A "reasonable" interpretation might be that Alice\'s date-of-birth exists but is unknown, whereas Bob\'s date-of-death does not exist (Bob is still alive). But why did we get to different answers?Another problem: null is an edge case.The answers are usually "yes", "no", "yes", "yes", "no", "yes" respectively. Crazy "mathematicians" call NaN "nullity" and say it compares equal to itself. SQL treats nulls as not equal to anything (so they behave like NaNs). One wonders what happens when you try to store \xc2\xb1\xe2\x88\x9e, \xc2\xb10, and NaNs into the same database column (there are 253 NaNs, half of which are "negative").To make matters worse, databases differ in how they treat NULL, and most of them aren\'t consistent (see NULL Handling in SQLite for an overview). It\'s pretty horrible.And now for the obligatory story:I recently designed a (sqlite3) database table with five columns a NOT NULL, b, id_a, id_b NOT NULL, timestamp. Because it\'s a generic schema designed to solve a generic problem for fairly arbitrary apps, there are two uniqueness constraints:id_a only exists for compatibility with an existing app design (partly because I haven\'t come up with a better solution), and is not used in the new app. Because of the way NULL works in SQL, I can insert (1, 2, NULL, 3, t) and (1, 2, NULL, 4, t) and not violate the first uniqueness constraint (because (1, 2, NULL) != (1, 2, NULL)).This works specifically because of how NULL works in a uniqueness constraint on most databases (presumably so it\'s easier to model "real-world" situations, e.g. no two people can have the same Social Security Number, but not all people have one).FWIW, without first invoking undefined behaviour, C++ references cannot "point to" null, and it\'s not possible to construct a class with uninitialized reference member variables (if an exception is thrown, construction fails).Sidenote: Occasionally you might want mutually-exclusive pointers (i.e. only one of them can be non-NULL), e.g. in a hypothetical iOS type DialogState = NotShown | ShowingActionSheet UIActionSheet | ShowingAlertView UIAlertView | Dismissed. Instead, I\'m forced to do stuff like assert((bool)actionSheet + (bool)alertView == 1).The undesirability of having having references/pointers be nullable by default.I don\'t think this is the main issue with nulls, the main issue with nulls is that they can mean two things:Languages which support Option types typically also forbid or discourage the use of uninitialized variables as well. How option types work including strategies to ease checking null cases such as pattern matching.In order to be effective, Option types need  to be supported directly in the language. Otherwise it takes a lot of boiler-plate code to simulate them.  Pattern-matching and type-inference are two keys language features making Option types easy to work with. For example:In F#:However, in a language like Java without direct support for Option types, we\'d have something like:Alternative solution such as message eating nilObjective-C\'s "message eating nil" is not so much a solution as an attempt to lighten the head-ache of null checking. Basically, instead of throwing a runtime exception when trying to invoke a method on a null object, the expression instead evaluates to null itself. Suspending disbelief, it\'s as if each instance method begins with if (this == null) return null;. But then there is information loss: you don\'t know whether the method returned null because it is valid return value, or because the object is actually null. It\'s a lot like exception swallowing, and doesn\'t make any progress addressing the issues with null outlined before.Assembly brought us addresses also known as untyped pointers. C mapped them directly as typed pointers but introduced Algol\'s null as a unique pointer value, compatible with all typed pointers. The big issue with null in C is that since every pointer can be null, one never can use a pointer safely without a manual check.In higher-level languages, having null is awkward since it really conveys two distinct notions:Having undefined variables is pretty much useless, and yields to undefined behavior whenever they occur. I suppose everybody will agree that having things undefined should be avoided at all costs.The second case is optionality and is best provided explicitly, for instance with an option type.Let\'s say we\'re in a transport company and we need to create an application to help create a schedule for our drivers. For each driver, we store a few informations such as: the driving licences they have and the phone number to call in case of emergency.In C we could have:As you observe, in any processing over our list of drivers we\'ll have to check for null pointers. The compiler won\'t help you, the safety of the program relies on your shoulders.In OCaml, the same code would look like this:Let\'s now say that we want to print the names of all the drivers along with their truck licence numbers.In C:In OCaml that would be:As you can see in this trivial example, there is nothing complicated in the safe version:Whereas in C, you could just have forgotten a null check and boom...Note : these code samples where not compiled, but I hope you got the ideas.Microsoft Research has a intersting project called Spec#It is a C# extension with not-null type and some mechanism to check your objects against not being null, although, IMHO, applying the design by contract principle may be more appropriate and more helpful for many troublesome situations caused by null references.Robert Nystrom offers a nice article here:http://journal.stuffwithstuff.com/2010/08/23/void-null-maybe-and-nothing/describing his thought process when adding support for absence and failure to his Magpie programming language.Coming from .NET background, I always thought null had a point, its useful. Until I came to know of structs and how easy it was working with them avoiding a lot of boilerplate code. Tony Hoare speaking at QCon London in 2009, apologized for inventing the null reference. To quote him:I call it my billion-dollar mistake. It was the invention of the null\n  reference in 1965. At that time, I was designing the first\n  comprehensive type system for references in an object oriented\n  language (ALGOL W). My goal was to ensure that all use of references\n  should be absolutely safe, with checking performed automatically by\n  the compiler. But I couldn\'t resist the temptation to put in a null\n  reference, simply because it was so easy to implement. This has led to\n  innumerable errors, vulnerabilities, and system crashes, which have\n  probably caused a billion dollars of pain and damage in the last forty\n  years. In recent years, a number of program analysers like PREfix and\n  PREfast in Microsoft have been used to check references, and give\n  warnings if there is a risk they may be non-null. More recent\n  programming languages like Spec# have introduced declarations for\n  non-null references. This is the solution, which I rejected in 1965.See this question too at programmersI\'ve always looked at Null (or nil) as being the absence of a value.Sometimes you want this, sometimes you don\'t.  It depends on the domain you are working with.  If the absence is meaningful: no middle name, then your application can act accordingly. On the other hand if the null value should not be there: The first name is null, then the developer gets the proverbial 2Â a.m. phone call.  I\'ve also seen code overloaded and over-complicated with checks for null. To me this means one of two things:\na) a bug higher up in the application tree\nb) bad/incomplete designOn the positive side - Null is probably one of the more useful notions for checking if something is absent, and languages without the concept of null will endup over-complicating things when it\'s time to do data validation.  In this case, if a new variable is not initialized, said languagues will usually set variables to an empty string, 0, or an empty collection.  However, if an empty string or 0 or empty collection are valid values for your application -- then you have a problem.  Sometimes this circumvented by inventing special/weird values for fields to represent an uninitialized state.  But then what happens when the special value is entered by a well-intentioned user? And let\'s not get into the mess this will make of data validation routines. \nIf the language supported the null concept all the concerns would vanish.Vector languages can sometimes get away with not having a null.The empty vector serves as a typed null in this case.