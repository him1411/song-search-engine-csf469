It seems they canceled in Python 3 all the easy way to quickly load a script by removing execfile() Is there an obvious alternative I\'m missing?According to the documentation, instead of UseSee:You are just supposed to read the file and exec the code yourself. 2to3 current replacesas(The compile call isn\'t strictly needed, but it associates the filename with the code object making debugging a little easier.)See:As suggested on the python-dev mailinglist recently, the runpy module might be a viable alternative. Quoting from that message:https://docs.python.org/3/library/runpy.html#runpy.run_pathThere are subtle differences to execfile:run_path always creates a new namespace. It executes the code as a module, so there is no difference between globals and locals (which is why there is only a init_globals argument). The globals are returned.execfile executed in the current namespace or the given namespace. The semantics of locals and globals, if given, were similar to locals and globals inside a class definition.run_path can not only execute files, but also eggs and directories (refer to its documentation for details).You could write your own function:If you really needed to...This one is better, since it takes the globals and locals from the caller:If the script you want to load is in the same directory than the one you run, maybe "import" will do the job ?If you need to dynamically import code the built-in function __ import__ and the module imp are worth looking at.test.py:If you\'re using Python 3.1 or later, you should also take a look at importlib.While exec(open("filename").read()) is often given as an alternative to execfile("filename"), it misses quite a few details that execfile supported.The following function for Python3.x is as close as I could get to having the same behavior as executing a file directly. That matches running python /path/to/somefile.py.Notes:Note that the above pattern will fail if you\'re using PEP-263 encoding declarations\nthat aren\'t ascii or utf-8. You need to find the encoding of the data, and encode it \ncorrectly before handing it to exec().Here\'s what I had (file is already assigned to the path to the file with the source code in both examples):Here\'s what I replaced it with:My favorite part: the second version works just fine in both Python 2 and 3, meaning it\'s not necessary to add in version dependent logic.Also, while not a pure Python solution, if you\'re using IPython (as you probably should anyway), you can do:Which is equally easy.locate the route of your folder installation (i have it in C:\\python34)\nthen execute on a regular cmd shellnow when you initiaze a shell, move to C:\\python34\\myscripts and use the classic commandI\'m just a newbie here so maybe it\'s pure luck if I found this :After trying to run a script from the interpreter prompt >>> with the commandfor which I got a "NameError: name \'execfile\' is not defined" I tried a very basic it worked well :-)I hope this can be helpful and thank you all for the great hints, examples and all those masterly commented pieces of code that are a great inspiration for newcomers ! I use Ubuntu 16.014 LTS x64.  Python 3.5.2 (default, Nov 17 2016, 17:05:23) \n[GCC 5.4.0 20160609] on linux