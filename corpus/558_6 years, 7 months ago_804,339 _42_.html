Python 2.6 introduced the str.format() method with a slightly different syntax from the existing % operator. Which is better and for what situations?The following uses each method and has the same outcome, so what is the difference?Furthermore when does string formatting occur in Python? For example, if my logging level is set to HIGH will I still take a hit for performing the following % operation? And if so, is there a way to avoid this?To answer your first question... .format just seems more sophisticated in many ways. An annoying thing about % is also how it can either take a variable or a tuple. You\'d think the following would always work:yet, if name happens to be (1, 2, 3), it will throw a TypeError. To guarantee that it always prints, you\'d need to dowhich is just ugly. .format doesn\'t have those issues. Also in the second example you gave, the .format example is much cleaner looking.Why would you not use it? To answer your second question, string formatting happens at the same time as any other operation - when the string formatting expression is evaluated. And Python, not being a lazy language, evaluates expressions before calling functions, so in your log.debug example, the expression "some debug info: %s"%some_infowill first evaluate to, e.g. "some debug info: roflcopters are active", then that string will be passed to log.debug(). Something that the modulo operator ( % ) can\'t do, afaik:resultVery useful.Another point: format(), being a function, can be used as an argument in other functions: Results in:Assuming you\'re using Python\'s logging module, you can pass the string formatting arguments as arguments to the .debug() method rather than doing the formatting yourself:which avoids doing the formatting unless the logger actually logs something.PEP 3101 proposes the replacement of the % operator with the new, advanced string formatting in Python 3, where it would be the default.But please be careful, just now I\'ve discovered one issue when trying to replace all % with .format in existing code: \'{}\'.format(unicode_string) will try to encode unicode_string and will probably fail.Just look at this Python interactive session log:s is just a string (called \'byte array\' in Python3) and u is a Unicode string (called \'string\' in Python3):When you give a Unicode object as a parameter to % operator it will produce a Unicode string even if the original string wasn\'t Unicode:but the .format function will raise "UnicodeEncodeError":and it will work with a Unicode argument fine only if the original string was Unicode.or if argument string can be converted to a string (so called \'byte array\')Update 2016: As of Python 3.6 you can  substitute variables into strings by name:Note the f" prefix. If you try this in Python 3.5 or earlier, you\'ll get a SyntaxError.See https://docs.python.org/3.6/reference/lexical_analysis.html#f-stringsYet another advantage of .format (which I don\'t see in the answers): it can take object properties.Or, as a keyword argument:This is not possible with % as far as I can tell.As I discovered today, the old way of formatting strings via % doesn\'t support Decimal, Python\'s module for decimal fixed point and floating point arithmetic, out of the box.Example (using Python 3.3.5):Output:0.00000000000000000000000312375239000000009907464850\n  0.00000000000000000000000312375239000000000000000000There surely might be work-arounds but you still might consider using the format() method right away. As a side note, you don\'t have to take a performance hit to use new style formatting with logging.  You can pass any object to logging.debug, logging.info, etc. that implements the __str__ magic method.  When the logging module has decided that it must emit your message object (whatever it is), it calls str(message_object) before doing so.  So you could do something like this:This is all described in the Python 3 documentation (https://docs.python.org/3/howto/logging-cookbook.html#formatting-styles).  However, it will work with Python 2.6 as well (https://docs.python.org/2.6/library/logging.html#using-arbitrary-objects-as-messages).One of the advantages of using this technique, other than the fact that it\'s formatting-style agnostic, is that it allows for lazy values e.g. the function expensive_func above.  This provides a more elegant alternative to the advice being given in the Python docs here: https://docs.python.org/2.6/library/logging.html#optimization.% gives much better performance than format from my test.format runs twice slower than %One situation where % may help is when you are formatting regex expressions. For example, raises IndexError. In this situation, you can use:This avoids writing the regex as \'{type_names} [a-z]{{2}}\'. This can be useful when you have two regexes, where one is used alone without format, but the concatenation of both is formatted.