How do I force Python\'s print function to output to the screen?This is not a duplicate of Disable output buffering - the linked question is attempting unbuffered output, while this is more general. The top answers in that question are too powerful or involved for this one (they\'re not good answers for this), and this question can be found on Google by a relative newbie.Print by default prints to sys.stdout.References:Running python -h, I see a command line option:-u     : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x\n           see man page for details on internal buffering relating to \'-u\'Here is the relevant doc.Since Python 3.3, you can force the normal print() function to flush without the need to use sys.stdout.flush(); just set the "flush" keyword argument to true.  From the documentation:print(*objects, sep=\' \', end=\'\\n\', file=sys.stdout, flush=False)Print objects to the stream file, separated by sep and followed by end. sep, end and file, if present, must be given as keyword arguments.All non-keyword arguments are converted to strings like str() does and written to the stream, separated by sep and followed by end. Both sep and end must be strings; they can also be None, which means to use the default values. If no objects are given, print() will just write end.The file argument must be an object with a write(string) method; if it is not present or None, sys.stdout will be used. Whether output is buffered is usually determined by file, but if the flush keyword argument is true, the stream is forcibly flushed.Also as suggested in this blog one can reopen sys.stdout in unbuffered mode:Each stdout.write and print operation will be automatically flushed afterwards.I suggest five ways of doing this:Using Python 3.3 or higher, you can just provide flush=True as a keyword argument to the print function: They did not backport the flush argument to Python 2.7 So if you\'re using Python 2 (or less than 3.3), and want code that\'s compatible with both 2 and 3, may I suggest the following compatibility code. (Note the __future__ import must be at/very "near the top of your module"):The above compatibility code will cover most uses, but for a much more thorough treatment, see the six module.Alternatively, you can just call file.flush() after printing, for example, with the print statement in Python 2:You can change the default for the print function by using functools.partial on the global scope of a module:if you look at our new partial function, at least in Python 3:We can see it works just like normal:And we can actually override the new default:Note again, this only changes the current global scope, because the print name on the current global scope will overshadow the builtin print function (or dereference the compatibility function, if using Python 2, in that current global scope).If you want to do this inside a function instead of on a module\'s global scope, you should give it a different name, e.g.:If you declare it a global in a function, you\'re changing it on the module\'s global namespace, so you should just put it in the global namespace, unless that specific behavior is exactly what you want.I think the best option here is to use the -u flag to get unbuffered output.or  From the docs:Force stdin, stdout and stderr to be totally unbuffered. On systems where it matters, also put stdin, stdout and stderr in binary mode.Note that there is internal buffering in file.readlines() and File Objects (for line in sys.stdin) which is not influenced by this option. To work around this, you will want to use file.readline() inside a while 1: loop.You can get this behavior for all python processes in the environment or environments that inherit from the environment if you set the environment variable to a nonempty string:e.g., in Linux or OSX:or Windows:from the docs:PYTHONUNBUFFEREDIf this is set to a non-empty string it is equivalent to specifying the -u option.Here\'s the help on the print function from Python 2.7.12 - note that there is no flush argument:Using the -u command-line switch works, but it is a little bit clumsy. It would mean that the program would potentially behave incorrectly if the user invoked the script without the -u option.  I usually use a custom stdout, like this:... Now all your print calls (which use sys.stdout implicitly), will be automatically flushed.Why not try using an unbuffered file?ORDan\'s idea doesn\'t quite work:The result:I believe the problem is that it inherits from the file class, which actually isn\'t necessary. According to the docs for sys.stdout:stdout and stderr needn\xe2\x80\x99t be built-in\n  file objects: any object is acceptable\n  as long as it has a write() method\n  that takes a string argument.so changingtomakes it work just fine.With Python 3.x they extended the print() function:print(*objects, sep=\' \', end=\'\\n\', file=sys.stdout, flush=False)So, you can just do:print("Foo", flush=True)Python Docs EntryHere is my version, which provides writelines() and fileno(), too:Loved Dan\'s solution! For python3 do:I did it like this in Python 3.4:In Python 3 you can overwrite print function with default set to flush = True 