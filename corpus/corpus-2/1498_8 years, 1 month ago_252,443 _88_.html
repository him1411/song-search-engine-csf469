I\'m iterating over a list of tuples in Python, and am attempting to remove them if they meet certain criteria. What should I use in place of code_to_remove_tup? I can\'t figure out how to remove the item in this fashion.You can use a list comprehension to create a new list containing only the elements you don\'t want to remove:Or, by assigning to the slice somelist[:], you can mutate the existing list to contain only the items you want:This approach could be useful if there are other references to somelist that need to reflect the changes.Instead of a comprehension, you could also use itertools. In Python 2:Or in Python 3:The answers suggesting list comprehensions are ALMOST correct -- except that they build a completely new list and then give it the same name the old list as, they do NOT modify the old list in place. That\'s different from what you\'d be doing by selective removal, as in @Lennart\'s suggestion -- it\'s faster, but if your list is accessed via multiple references the fact that you\'re just reseating one of the references and NOT altering the list object itself can lead to subtle, disastrous bugs.Fortunately, it\'s extremely easy to get both the speed of list comprehensions AND the required semantics of in-place alteration -- just code:Note the subtle difference with other answers: this one is NOT assigning to a barename - it\'s assigning to a list slice that just happens to be the entire list, thereby replacing the list contents within the same Python list object, rather than just reseating one reference (from previous list object to new list object) like the other answers.You need to take a copy of the list and iterate over it first, or the iteration will fail with what may be unexpected results.For example (depends on what type of list):An example:You need to go backwards otherwise it\'s a bit like sawing off the tree-branch that you are sitting on :-)Your best approach for such an example would be a list comprehensionIn cases where you\'re doing something more complex than calling a determine function, I prefer constructing a new list and simply appending to it as I go.  For exampleCopying the list using remove might make your code look a little cleaner, as described in one of the answers below.  You should definitely not do this for extremely large lists, since this involves first copying the entire list, and also performing an O(n) remove operation for each element being removed, making this an O(n^2) algorithm.For those that like functional programming:orThe official Python 2 tutorial 4.2. "for Statements" says:If you need to modify the sequence you are iterating over while inside the loop (for example to duplicate selected items), it is recommended that you first make a copy. Iterating over a sequence does not implicitly make a copy. The slice notation makes this especially convenient:which is what was suggested at: https://stackoverflow.com/a/1207427/895245The Python 2 documentation 7.3. "The for statement" gives the same advice:Note: There is a subtlety when the sequence is being modified by the loop (this can only occur for mutable sequences, i.e. lists). An internal counter is used to keep track of which item is used next, and this is incremented on each iteration. When this counter has reached the length of the sequence the loop terminates. This means that if the suite deletes the current (or a previous) item from the sequence, the next item will be skipped (since it gets the index of the current item which has already been treated). Likewise, if the suite inserts an item in the sequence before the current item, the current item will be treated again the next time through the loop. This can lead to nasty bugs that can be avoided by making a temporary copy using a slice of the whole sequence, e.g.,Could Python do this better?It seems like this particular Python API could be improved. Compare it, for instance, with its Java counterpart ListIterator, which makes it crystal clear that you cannot modify a list being iterated except with the iterator itself, and gives you efficient ways to do so without copying the list. Come on, Python!It might be smart to also just create a new list if the current list item meets the desired criteria. so:and to avoid having to re-code the entire project with the new lists name:note, from Python documentation: copy.copy(x) \n  Return a shallow copy of x.copy.deepcopy(x) \n  Return a deep copy of x.This answer was originally written in response to a question which has since been marked as duplicate:\nRemoving coordinates from list on pythonThere are two problems in your code:1) When using remove(), you attempt to remove integers whereas you need to remove a tuple.2) The for loop will skip items in your list.Let\'s run through what happens when we execute your code:The first problem is that you are passing both \'a\' and \'b\' to remove(), but remove() only accepts a single argument. So how can we get remove() to work properly with your list? We need to figure out what each element of your list is. In this case, each one is a tuple. To see this, let\'s access one element of the list (indexing starts at 0):Aha! Each element of L1 is actually a tuple. So that\'s what we need to be passing to remove(). Tuples in python are very easy, they\'re simply made by enclosing values in parentheses. "a, b" is not a tuple, but "(a, b)" is a tuple. So we modify your code and run it again:This code runs without any error, but let\'s look at the list it outputs: Why is (1,-2) still in your list? It turns out modifying the list while using a loop to iterate over it is a very bad idea without special care. The reason that (1, -2) remains in the list is that the locations of each item within the list changed between iterations of the for loop. Let\'s look at what happens if we feed the above code a longer list:As you can infer from that result, every time that the conditional statement evaluates to true and a list item is removed, the next iteration of the loop will skip evaluation of the next item in the list because its values are now located at different indices.The most intuitive solution is to copy the list, then iterate over the original list and only modify the copy. You can try doing so like this:However, the output will be identical to before:This is because when we created L2, python did not actually create a new object. Instead, it merely referenced L2 to the same object as L1. We can verify this with \'is\' which is different from merely "equals" (==).We can make a true copy using copy.copy(). Then everything works as expected:Finally, there is one cleaner solution than having to make an entirely new copy of L1. The reversed() function:Unfortunately, I cannot adequately describe how reversed() works. It returns a \'listreverseiterator\' object when a list is passed to it. For practical purposes, you can think of it as creating a reversed copy of its argument. This is the solution I recommend.I needed to do this with a huge list, and duplicating the list seemed expensive, especially since in my case the number of deletions would be few compared to the items that remain. I took this low-level approach.What I don\'t know is how efficient a couple of deletes are compared to copying a large list. Please comment if you have any insight.You might want to use filter() available as the built-in.For more details check hereIf you want to do anything else during the iteration, it may be nice to get both the index (which guarantees you being able to reference it, for example if you have a list of dicts) and the actual list item contents.enumerate gives you access to the item and the index at once. reversed is so that the indices that you\'re going to later delete don\'t change on you. You can try for-looping in reverse so for some_list you\'ll do something like:This way the index is aligned and doesn\'t suffer from the list updates (regardless whether you pop cur element or not).I needed to do something similar and in my case the problem was memory - I needed to merge multiple dataset objects within a list, after doing some stuff with them, as a new object, and needed to get rid of each entry I was merging to avoid duplicating all of them and blowing up memory. In my case having the objects in a dictionary instead of a list worked fine:``````One possible solution, useful if you don\'t want to use comprehensions:TLDR:I wrote a library that allows you to do this:It\'s best to use another method if possible that doesn\'t require modifying your iterable while iterating over it, but for some algorithms it might not be that straight forward. And so if you are sure that you really do want the code pattern described in the original question, it is possible.Should work on all mutable sequences not just lists.Full answer:Edit: The last code example in this answer gives a use case for why you might sometimes want to modify a list in place rather than use a list comprehension. The first part of the answers serves as tutorial of how an array can be modified in place.The solution follows on from this answer (for a related question) from senderle. Which explains how the the array index is updated while iterating through a list that has been modified. The solution below is designed to correctly track the array index even if the list is modified.Download fluidIter.py from here https://github.com/alanbacon/FluidIterator, it is just a single file so no need to install git. There is no installer so you will need to make sure that the file is in the python path your self. The code has been written for python 3 and is untested on python 2.This will produce the following output:Above we have used the pop method on the fluid list object. Other common iterable methods are also implemented such as del fluidL[i], .remove, .insert, .append, .extend. The list can also be modified using slices (sort and reverse methods are not implemented).The only condition is that you must only modify the list in place, if at any point fluidL or l were reassigned to a different list object the code would not work. The original fluidL object would still be used by the for loop but would become out of scope for us to modify.i.e.If we want to access the current index value of the list we cannot use enumerate, as this only counts how many times the for loop has run. Instead we will use the iterator object directly.This will output the following:The FluidIterable class just provides a wrapper for the original list object. The original object can be accessed as a property of the fluid object like so:More examples / tests can be found in the if __name__ is "__main__": section at the bottom of fluidIter.py. These are worth looking at because they explain what happens in various situations. Such as: Replacing a large sections of the list using a slice. Or using (and modifying) the same iterable in nested for loops.As I stated to start with: this is a complicated solution that will hurt the readability of your code and make it more difficult to debug. Therefore other solutions such as the list comprehensions mentioned in David Raznick\'s answer should be considered first. That being said, I have found times where this class has been useful to me and has been easier to use than keeping track of the indices of elements that need deleting.Edit: As mentioned in the comments, this answer does not really present a problem for which this approach provides a solution. I will try to address that here:List comprehensions provide a way to generate a new list but these approaches tend to look at each element in isolation rather than the current state of the list as a whole.i.e.But what if the result of the testFunc depends on the elements that have been added to newList already? Or the elements still in oldList that might be added next? There might still be a way to use a list comprehension but it will begin to lose it\'s elegance, and for me it feels easier to modify a list in place.The code below is one example of an algorithm that suffers from the above problem. The algorithm will reduce a list so that no element is a multiple of any other element.The output and the final reduced list are shown belowRight away you want to create a copy of the list so you can have that as a reference when you are iterating through and deleting tuples in that list that meet a certain criteria.Then it depends on what type of list you want for the output whether that be a list of the removed tuples or a list of the tuples that are not removed.As David pointed out, I recommend list comprehension to keep the elements you don\'t want to remove.You can write thisHere i is index and item is content.