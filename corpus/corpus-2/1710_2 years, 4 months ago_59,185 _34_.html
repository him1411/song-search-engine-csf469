I recently compared the processing speeds of [] and list() and was surprised to discover that [] runs more than three times faster than list(). I ran the same test with {} and dict() and the results were practically identical: [] and {} both took around 0.128sec / million cycles, while list() and dict() took roughly 0.428sec / million cycles each.Why is this? Do [] and {} (and probably () and \'\', too) immediately pass back a copies of some empty stock literal while their explicitly-named counterparts (list(), dict(), tuple(), str()) fully go about creating an object, whether or not they actually have elements?I have no idea how these two methods differ but I\'d love to find out.\nI couldn\'t find an answer in the docs or on SO, and searching for empty brackets turned out to be more problematic than I\'d expected.I got my timing results by calling timeit.timeit("[]") and timeit.timeit("list()"), and timeit.timeit("{}") and timeit.timeit("dict()"), to compare lists and dictionaries, respectively. I\'m running Python 2.7.9.I recently discovered "Why is if True slower than if 1?" that compares the performance of if True to if 1 and seems to touch on a similar literal-versus-global scenario; perhaps it\'s worth considering as well.Because [] and {} are literal syntax. Python can create bytecode just to create the list or dictionary objects:list() and dict() are separate objects. Their names need to be resolved, the stack has to be involved to push the arguments, the frame has to be stored to retrieve later, and a call has to be made. That all takes more time.For the empty case, that means you have at the very least a LOAD_NAME (which has to search through the global namespace as well as the __builtin__ module) followed by a CALL_FUNCTION, which has to preserve the current frame:You can time the name lookup separately with timeit:The time discrepancy there is probably a dictionary hash collision. Subtract those times from the times for calling those objects, and compare the result against the times for using literals:So having to call the object takes an additional 1.00 - 0.31 - 0.30 == 0.39 seconds per 10 million calls.You can avoid the global lookup cost by aliasing the global names as locals (using a timeit setup, everything you bind to a name is a local):but you never can overcome that CALL_FUNCTION cost.list() requires a global lookup and a function call but [] compiles to a single instruction. See:Because list is a function to convert say a string to a list object, while [] is used to create a list off the bat. Try this (might make more sense to you):WhileGives you a actual list containing whatever you put in it.The answers here are great, to the point and fully cover this question. I\'ll drop a further step down from byte-code for those interested. I\'m using the most recent repo of CPython; older versions behave similar in this regard but slight changes might be in place.Here\'s a break down of the execution for each of these, BUILD_LIST for [] and CALL_FUNCTION for list().You should just view the horror:Terribly convoluted, I know. This is how simple it is:No wonder it is fast! It\'s custom-made for creating new lists, nothing else :-)Here\'s the first thing you see when you peek at the code handling CALL_FUNCTION:Looks pretty harmless, right? Well, no, unfortunately not, call_function is not a straightforward guy that will call the function immediately, it can\'t. Instead, it grabs the object from the stack, grabs all arguments of the stack and then switches based on the type of the object; is it a:We\'re calling the list type, the argument passed in to call_function is PyList_Type. CPython now has to call a generic function to handle any callable objects named _PyObject_FastCallKeywords, yay more function calls.This function again makes some checks for certain function types (which I cannot understand why) and then, after creating a dict for kwargs if required, goes on to call _PyObject_FastCallDict._PyObject_FastCallDict finally gets us somewhere! After performing even more checks  it grabs the tp_call slot from the type of the type we\'ve passed in, that is, it grabs type.tp_call. It then proceeds to create a tuple out of of the arguments passed in with _PyStack_AsTuple and, finally, a call can finally be made!tp_call, which matches type.__call__ takes over and finally creates the list object. It calls the lists __new__ which corresponds to PyType_GenericNew and allocates memory for it with PyType_GenericAlloc: This is actually the part where it catches up with PyList_New, finally. All the previous are necessary to handle objects in a generic fashion.In the end, type_call calls list.__init__ and initializes the list with any available arguments, then we go on a returning back the way we came. :-)Finally, remmeber the LOAD_NAME, that\'s another guy that contributes here.It\'s easy to see that, when dealing with our input, Python generally has to jump through hoops in order to actually find out the appropriate C function to do the job. It doesn\'t have the curtesy of immediately calling it because it\'s dynamic, someone might mask list (and boy do many people do) and another path must be taken. This is where list() loses much: The exploring Python needs to do to find out what the heck it should do.Literal syntax, on the other hand, means exactly one thing; it cannot be changed and always behaves in a pre-determined way.Footnote: All function names are subject to change from one release to the other. The point still stands and most likely will stand in any future versions, it\'s the dynamic look-up that slows things down.