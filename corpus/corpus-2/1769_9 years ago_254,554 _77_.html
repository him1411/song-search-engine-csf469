Apparently xrange is faster but I have no idea why it\'s faster (and no proof besides the anecdotal so far that it is faster) or what besides that is different aboutrange creates a list, so if you do range(1, 10000000) it creates a list in memory with 9999999 elements.xrange is a sequence object that  evaluates lazily.  range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.xrange is a generator, so it is a sequence object is a that  evaluates lazily.  This is true, but in Python 3, range will be implemented by the Python 2 xrange(). If you need to actually generate the list, you will need to do:Remember, use the timeit module to test which of small snipps of code is faster!Personally, I always use range(), unless I were dealing with really huge lists -- as you can see, time-wise, for a list of a million entries, the extra overhead is only 0.04 seconds.  And as Corey points out, in Python 3.0 xrange will go away and range will give you nice iterator behaviour anyway.xrange only stores the range params and generates the numbers on demand. However the C implementation of Python currently restricts its args to C longs:Note that in Python 3.0 there is only range and it behaves like the 2.x xrange but without the limitations on minimum and maximum end points.xrange returns an iterator and only keeps one number in memory at a time.  range keeps the entire list of numbers in memory.Do spend some time with the Library Reference. The more familiar you are with it, the faster you can find answers to questions like this. Especially important are the first few chapters about builtin objects and types.The advantage of the xrange type is that an xrange object will always \n  take the same amount of memory, no matter the size of the range it represents. \n  There are no consistent performance advantages.Another way to find quick information about a Python construct is the docstring and the help-function:range creates a list, so if you do range(1, 10000000) it creates a list in memory with 10000000 elements.\n  xrange is a generator, so it evaluates lazily.This brings you two advantages:It is for optimization reasons.range() will create a list of values from start to end (0 .. 20 in your example). This will become an expensive operation on very large ranges.xrange() on the other hand is much more optimised. it will only compute the next value when needed (via an xrange sequence object) and does not create a list of all values like range() does.I am shocked nobody read doc:This function is very similar to range(), but returns an xrange object instead of a list. This is an opaque sequence type which yields the same values as the corresponding list, without actually storing them all simultaneously. The advantage of xrange() over range() is minimal (since xrange() still has to create the values when asked for them) except when a very large range is used on a memory-starved machine or when all of the range\xe2\x80\x99s elements are never used (such as when the loop is usually terminated with break).You will find the advantage of xrange over range in this simple example:The above example doesn\'t reflect anything substantially better in case of xrange.Now look at the following case where range is really really slow, compared to xrange.With range, it already creates a list from 0 to 100000000(time consuming), but xrange is a generator and it only generates numbers based on the need, that is, if the iteration continues.In Python-3, the implementation of the range functionality is same as that of xrange in Python-2, while they have done away with xrange in Python-3Happy Coding!! range(): range(1, 10) returns a list from 1 to 10 numbers & hold whole list in memory.xrange(): Like range(), but instead of returning a list, returns an object that generates the numbers in the range on demand. For looping, this is lightly faster than range() and more memory efficient.\n xrange() object like an iterator and generates the numbers on demand.(Lazy Evaluation)range(x,y) returns a list of each number in between x and y if you use a for loop, then range is slower. In fact, range has a bigger Index range. range(x.y) will print out a list of all the numbers in between x and yxrange(x,y) returns xrange(x,y) but if you used a for loop, then xrange is faster. xrange has a smaller Index range. xrange will not only print out xrange(x,y) but it will still keep all the numbers that are in it.If you use a for loop, then it would workThere isn\'t much difference when using loops, though there is a difference when just printing it!Some of the other answers mention that Python 3 eliminated 2.x\'s range and renamed 2.x\'s xrange to range. However, unless you\'re using 3.0 or 3.1 (which nobody should be), it\'s actually a somewhat different type.As the 3.1 docs say:Range objects have very little behavior: they only support indexing, iteration, and the len function.However, in 3.2+, range is a full sequence\xe2\x80\x94it supports extended slices, and all of the methods of collections.abc.Sequence with the same semantics as a list.*And, at least in CPython and PyPy (the only two 3.2+ implementations that currently exist), it also has constant-time implementations of the index and count methods and the in operator (as long as you only pass it integers). This means writing 123456 in r is reasonable in 3.2+, while in 2.7 or 3.1 it would be a horrible idea.* The fact that issubclass(xrange, collections.Sequence) returns True in 2.6-2.7 and 3.0-3.1 is a bug that was fixed in 3.2 and not backported.xrange() and range() in python works similarly as for the user , but the difference comes when we are talking about how the memory is allocated in using both the function.When we are using range() we allocate memory for all the variables it is generating, so it is not recommended to use with larger no. of variables to be generated.xrange() on the other hand generate only a particular value at a time and can only be used with the for loop to print all the values required.In python 2.xrange(x) returns a list, that is created in memory with x elements.xrange(x) returns an xrange object which is a generator obj which generates the numbers on demand. they are computed during for-loop(Lazy Evaluation).For looping, this is slightly faster than range() and more memory efficient.When testing range against xrange in a loop (I know I should use timeit, but this was swiftly hacked up from memory using a simple list comprehension example) I found the following:which gives:Or, using xrange in the for loop:Is my snippet testing properly? Any comments on the slower instance of xrange? Or a better example :-)range generates the entire list and returns it.  xrange does not -- it generates the numbers in the list on demand.Read the following post for the comparison between range and xrange with graphical analysis.Python range Vs xrangexrange uses an iterator (generates values on the fly), range returns a list.What?\nrange returns a static list at runtime.\nxrange returns an object (which acts like a generator, although it\'s certainly not one) from which values are generated as and when required.When to use which?  PS: Python 3.x\'s range function == Python 2.x\'s xrange function.On a requirement for scanning/printing of 0-N items , range and xrange works as follows.range() - creates a new list in the memory and takes the whole 0 to N items(totally N+1) and prints them.\nxrange() - creates a iterator instance that scans through the items and keeps only the current encountered item into the memory , hence utilising same amount of memory all the time.In case the required element is somewhat at the beginning of the list only then it saves a good amount of time and memory.The difference decreases for smaller arguments to range(..) / xrange(..):In this case xrange(100) is only about 20% more efficient.See this post to find difference between range and xrange:To quote:range returns exactly what you think: a list of consecutive\n  integers, of a defined length beginning with 0. xrange, however,\n  returns an "xrange object", which acts a great deal like an iteratorRange returns a list while xrange returns an xrange object which takes the same memory irrespective of the range size,as in this case,only one element is generated and available per iteration whereas in case of using range, all the elements are generated at once and are available in the memory.range :-range will populate everything at once.which means every number of the range will occupy the memory.xrange :-xrange is something like generator ,it will comes into picture when you want the range of numbers but you dont want them to be stored,like when you want to use in for loop.so memory efficient.Everyone has explained it greatly. But I wanted it to see it for myself. I use python3. So, I opened the resource monitor (in Windows!), and first, executed the following command first:and then checked the change in \'In Use\' memory. It was insignificant.\nThen, I ran the following code:And it took a big chunk of the memory for use, instantly. And, I was convinced.\nYou can try it for yourself.If you are using Python 2X, then replace \'range()\' with \'xrange()\' in the first code and \'list(range())\' with \'range()\'.From the help docs.Python 2.7.12Python 3.5.2Difference is apparent. In Python 2.x, range returns a list, xrange returns an xrange object which is iterable.In Python 3.x, range becomes xrange of Python 2.x, and xrange is removed.