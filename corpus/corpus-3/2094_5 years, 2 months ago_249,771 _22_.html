I\'m trying to follow PEP 328, with the following directory structure:In core_test.py I have the following import statementHowever, when I run, I get the following error:Searching around I found "relative path not working even with __init__.py" and "Import a module from a relative path" but they didn\'t help.Is there anything I\'m missing here?Yes. You\'re not using it as a package.To elaborate on @Ignacio\'s answer:The Python import mechanism works relative to the __name__ of the current file.  When you execute a file directly, it doesn\'t have its usual name, but has "__main__" as its name instead.  So relative imports don\'t work.You can, as Igancio suggested, execute it using the -m option.  If you have a part of your package that is meant to be run as a script, you can also use the __package__ attribute to tell that file what name it\'s supposed to have in the package hierarchy. See http://www.python.org/dev/peps/pep-0366/ for details.You can use import components.core directly if you append the current directory to sys.path:It depends on how you want to launch your script.If you want to launch your UnitTest from the command line in a classic way, that is:Then, since in this case \'components\' and \'tests\' are siblings folders, you can import the relative module either using the insert or the append method of the sys.path module.\nSomething like:Otherwise, you can launch your script with the \'-m\' argument (note that in this case, we are talking about a package, and thus you must not give the \'.py\' extension), that is:In such a case, you can simply use the relative import as you were doing:You can finally mix the two approaches, so that your script will work no matter how it is called.\nFor example:If your use case is for running tests, and it seams that it is, then you can do the following. Instead of running your test script as python core_test.py use a testing framework such as pytest. Then on the command line you can enterThat will run the tests in your directory. This gets around the issue of __name__ being __main__ that was pointed out by @BrenBarn. Next, put an empty __init__.py file into your test directory, this will make the test directory part of your package. Then you will be able to doHowever, if you run your test script as a main program then things will fail once again. So just use the test runner. Maybe this also works with other test runners such as nosetests but i haven\'t checked it. Hope this helps.  My quick-fix is to add the directory to the path:In core_test.py, do the following: