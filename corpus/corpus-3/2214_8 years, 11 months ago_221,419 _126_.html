I was writing a program in C++ to find all solutions of ab = c, where a, b and c together use all the digits 0-9 exactly once. The program looped over values of a and b, and ran a digit-counting routine each time on a, b and ab to check if the digits condition was satisfied.However, spurious solutions can be generated when ab overflows the integer limit. I ended up checking for this using code like:Is there a better way of testing for overflow? I know that some chips have an internal flag that is set when overflow occurs, but I\'ve never seen it accessed through C or C++.There is a way to determine whether an operation is likely to overflow, using the positions of the most-significant one-bits in the operands and a little basic binary-math knowledge.For addition, any two operands will result in (at most) one bit more than the largest operand\'s highest one-bit. For example:For multiplication, any two operands will result in (at most) the sum of the bits of the operands. For example:Similarly, you can estimate the maximum size of the result of a to the power of b like this:(Substitute the number of bits for your target integer, of course.)I\'m not sure of the fastest way to determine the position of the highest one-bit in a number, here\'s a brute-force method:It\'s not perfect, but that\'ll give you a good idea whether any two numbers could overflow before you do the operation. I don\'t know whether it would be faster than simply checking the result the way you suggested, because of the loop in the highestOneBitPosition function, but it might (especially if you knew how many bits were in the operands beforehand).I see you\'re using unsigned integers. By definition, in C (don\'t know about C++), unsigned arithmetic does not overflow ... so, at least for C, your point is moot :)With signed integers, once there has been overflow, Undefined Behaviour has occurred and your program can do anything (for example: render tests inconclusive). To create a conforming program you need to test for overflow before generating said overflow. The method can be used with unsigned integers toofor division (except for the INT_MIN and -1 special case) there is no possibility of going over INT_MIN or INT_MAX.Clang 3.4+ and GCC 5+ offer checked arithmetic builtins. They offer a very fast solution to this problem, especially when compared to bit-testing safety checks.For the example in OP\'s question, it would work like that:The Clang documentation doesn\'t specify whether c_test contains the overflowed result if an overflow occurred, but the GCC documentation says that it does. Given that these two like to be __builtin-compatible, it\'s probably safe to assume that this is how Clang works too.There is a __builtin for each arithmetic operation that can overflow (addition, subtraction, multiplication), with signed and unsigned variants, for int sizes, long sizes, and long long sizes. The syntax for the name is __builtin_[us](operation)(l?l?)_overflow:So for a checked signed long integer addition, it would be __builtin_saddl_overflow. The full list can be found on the Clang documentation page.GCC 5+ and Clang 3.8+ additionally offer generic builtins that work without specifying the type of the values: __builtin_add_overflow, __builtin_sub_overflow and __builtin_mul_overflow. These also work on types smaller than int. The builtins lower to what\'s best for the platform. On x86, they check the carry, overflow and sign flags.Visual Studio\'s cl.exe does not have any equivalent, although you will be able to build Windows programs with Clang starting with VS2015. If that\'s an option to you, you could make small wrapper functions for the checked arithmetic builtins and build the rest with cl, as usual.Some compilers provide access to the integer overflow flag in the CPU which you could then test but this isn\'t standard.You could also test for the possibility of overflow before you perform the multiplication:Warning: GCC can optimize away an overflow check when compiling with -O2.\nThe option -Wall will give you a warning in some cases likebut not in this example:The only safe way is to check for overflow before it occurs, as described in the CERT paper, and this would be incredibly tedious to use systematically.Compiling with -fwrapv solves the problem but disables some optimizations.We desperately need a better solution. I think the compiler should issue a warning by default when making an optimization that relies on overflow not occurring. The present situation allows the compiler to optimize away an overflow check, which is unacceptable in my opinion.clang now support dynamic overflow checks for both signed and unsigned integers. See -fsanitize=integer switch. For now it is only one C++ compiler with fully supported dynamic overflow checking for debug purpose.Here is a "non-portable" solution to the question. The Intel x86 and x64 CPUs have the so-called EFLAGS-register ( http://en.wikipedia.org/wiki/EFLAGS ), which is filled by the processor after each integer arithmetic operation. I will skip a detailed description here. The relevant flags are the "Overflow" Flag (mask 0x800) and the "Carry" Flag (mask 0x1). To interpret them correctly, one should consider if the operands are of signed or unsigned type.Here is a practical way to check the flags from C/C++. The following code will work on Visual Studio 2005 or newer (both 32 and 64 bit), as well as on GNU C/C++ 64 bit.If the operands were multiplied without overflow, you would get a return value of 0 from query_intel_eflags( 0x801 ), i.e. neither the carry nor the overflow flags are set. In the provided example code of main(), an overflow occurs and the both flags are set to 1. This check does not imply any further calculations, so it should be quite fast.I see that a lot of people answered the question about overflow, but I wanted to address his original problem. He said the problem was to find ab=c such that all digits are used without repeating. Ok, that\'s not what he asked in this post, but I\'m still think that it was necessary to study the upper bound of the problem and conclude that he would never need to calculate or detect an overflow (note: I\'m not proficient in math so I did this step by step, but the end result was so simple that this might have a simple formula).The main point is that the upper bound that the problem requires for either a, b or c is 98.765.432. Anyway, starting by splitting the problem in the trivial and non trivial parts:Now we just need to show that no other solution is possible and only the permutations are valid (and then the code to print them is trivial). We go back to the upper bound. Actually the upper bound is c \xe2\x89\xa4 98.765.432. It\'s the upper bound because it\'s the largest number with 8 digits (10 digits total minus 1 for each a and b). This upper bound is only for c because the bounds for a and b must be much lower because of the exponential growth, as we can calculate, varying b from 2 to the upper bound:Notice, for example the last line: it says that 1.97^27 ~98M. So, for example, 1^27 == 1 and 2^27 == 134.217.728 and that\'s not a solution because it has 9 digits (2 > 1.97 so it\'s actually bigger than what should be tested). As it can be seen, the combinations available for testing a and b are really small. For b == 14, we need to try 2 and 3. For b == 3, we start at 2 and stop at 462. All the results are granted to be less than  ~98M.Now just test all the combinations above and look for the ones that do not repeat any digits:None of them matches the problem (which can also be seen by the absence of \'0\', \'1\', ..., \'9\').The example code that solves it follows. Also note that\'s written in python, not because it needs arbitrary precision integers (the code doesn\'t calculate anything bigger than 98 million), but because we found out that the amount of tests is so small that we should use a high level language to make use of its built-in containers and libraries (also note: the code has 28 lines).If you have a datatype which is bigger than the one you want to test (say you do a 32-bit add and you have a 64-bit type). Then this will detect if an overflow occurred. My example is for an 8-bit add. But can be scaled up.It is based on the concepts explained on this page: http://www.cs.umd.edu/class/spring2003/cmsc311/Notes/Comb/overflow.htmlFor a 32-bit example, 0xff becomes 0xffffffff and 0x80 becomes 0x80000000 and finally uint16_t becomes a uint64_t.NOTE: this catches integer addition/subtraction overflows, and I realized that your question involves multiplication. In which case, division is likely the best approach. This is commonly a way that calloc implementations make sure that the params don\'t overflow as they are multiplied to get the final size.The simplest way is to convert your unsigned longs into unsigned long longs, do your multiplication, and compare the result to 0x100000000LL.You\'ll probably find that this is more efficient than doing the division as you\'ve done in your example.Oh, and it\'ll work in both C and C++ (as you\'ve tagged the question with both).Just been taking a look at the glibc manual. There\'s a mention of an integer overflow trap (FPE_INTOVF_TRAP) as part of SIGFPE. That would be ideal, apart from the nasty bits in the manual:FPE_INTOVF_TRAP\n      Integer overflow (impossible in a C program unless you enable overflow trapping in a hardware-specific fashion). A bit of a shame really.For unsigned integers, just check that the result is smaller than one of the arguments :For signed integers you can check the signs of the arguments and of the result.\nintegers of different signs can\'t overflow,\nand integers of same sign overflow only is the result is of different sign :You can\'t access the overflow flag from C/C++. Some compilers allow you to insert trap instructions into the code. On GCC the option is -ftrapv (but I have to admit that I\'ve never used it. Will check it after posting).The only portable and compiler independent thing you can do is to check for overflows on your own. Just like you did in your example. Edit:Just checked: -ftrapv seems to do nothing on x86 using the lastest GCC. Guess it\'s a left over from an old version or specific to some other architecture. I had expected the compiler to insert an INTO opcode after each addition. Unfortunately it does not do this.Although it has been two years, I felt I might as well add my penithworth for a really fast way to detect overflow for at least additions, which might give a lead for multiplication, division and power-ofThe idea is that exactly because the processor will just let the value wrap back to zero and that C/C++ is to abstracted from any specific processor, you can:This both ensures that if one operand is zero and one isn\'t, then overflow won\'t be falsely detected, and is significantly faster than a lot of NOT/XOR/AND/test operations as previously suggested.Edit:\nAs pointed out, this approach although better than other more elaborate ways is still optimisable. The following is a revision of the original code containing the optimisation:I needed to answer this same question for floating point numbers, where bit masking and shifting does not look promising. The approach I settled on works for signed and unsigned, integer and floating point numbers. It works even if there is no larger data type to promote to for intermediate calculations. It is not the most efficient for all of these types, but because it does work for all of them, it is worth using.Signed Overflow test, Addition and Subtraction:Obtain the constants that represent the largest and smallest possible values for the type,\nMAXVALUE and MINVALUE.Compute and compare the signs of the operands. a. If either value is zero, then neither addition nor subtraction can overflow. Skip remaining tests.b. If the signs are opposite, then addition cannot overflow. Skip remaining tests.c. If the signs are the same, then subtraction cannot overflow. Skip remaining tests.Test for positive overflow of MAXVALUE.a. If both signs are positive and MAXVALUE - A < B, then addition will overflow.b. If the sign of B is negative and MAXVALUE - A < -B, then subtraction will overflow.Test for negative overflow of MINVALUE.a. If both signs are negative and MINVALUE - A > B, then addition will overflow.b. If the sign of A is negative and MINVALUE - A > B, then subtraction will overflow.Otherwise, no overflow.Signed Overflow test, Multiplication and Division:Obtain the constants that represent the largest and smallest possible values for the type,\nMAXVALUE and MINVALUE.Compute and compare the magnitudes (absolute values) of the operands to one. (Below, assume A and B are these magnitudes, not the signed originals.)a. If either value is zero, multiplication cannot overflow, and division will yield zero or an infinity.b. If either value is one, multiplication and division cannot overflow.c. If the magnitude of one operand is below one and of the other is greater than one, multiplication cannot overflow.d. If the magnitudes are both less than one, division cannot overflow.Test for positive overflow of MAXVALUE.a. If both operands are greater than one and MAXVALUE / A < B, then multiplication will overflow.b. If B is less than one and MAXVALUE * B < A, then division will overflow.Otherwise, no overflow.Note: Minimum overflow of MINVALUE is handled by 3, because we took absolute values. However, if\nABS(MINVALUE) > MAXVALUE, then we will have some rare false positives.The tests for underflow are similar, but involve EPSILON (the smallest positive number greater than zero).Another interesting tool: http://embed.cs.utah.edu/ioc/This is a patched clang compiler, which adds checks to the code at compile time.\nSo you get output looking like this:CERT has developed a new approach to detecting and reporting signed integer overflow, unsigned integer wrapping, and integer truncation using the "as-if" infinitely ranged (AIR) integer model.  CERT has published a technical report describing the model and produced a working prototype based on GCC 4.4.0 and GCC 4.5.0.  The AIR integer model either produces a value equivalent to one that would have been obtained using infinitely ranged integers or results in a runtime constraint violation. Unlike previous integer models, AIR integers do not require precise traps, and consequently do not break or inhibit most existing optimizations.Calculate the results with doubles. They have 15 significant digits. Your requirement has a hard upper bound on c of 108 — it can have at most 8 digits. Hence, the result will be precise if it\'s in range, and it will not overflow otherwise.Another variant of solution using assembler is an external procedure. This example for unsigned integer multiplication using g++ and fasm under linux x64.This procedure multiplies two unsigned integer arguments (32 bits) (according to specification for amd64 (section 3.2.3 Parameter Passing) If the class is INTEGER, the next available register of the sequence %rdi,%rsi,%rdx,%rcx,%r8 and %r9 is used(edi and esi registers in my code)) and returns the result or 0 if an overflow has occured.test:link program with asm object file. In my case in Qt Creator add it to LIBS in a .pro fileTry this macro to test the overflow bit of 32-bit machines (adapted the solution of Angel Sinigersky)I defined it as a macro because otherwise the overflow bit would have been overwritten.Subsequent is a little application with the code segement above:You can\'t access the overflow flag from C/C++.I don\'t agree with this. You could write some inline asm and use a jo (jump overflow) instruction assuming you are on x86 to trap the overflow. Of course you code would no longer be portable to other architectures.look at info as and info gcc.Catching Integer Overflows in C points out a solution more general than the one discussed by CERT (it is more general in term of handled types), even if it requires some GCC extensions (I don\'t know how widely supported they are).Inline assembly lets you check the overflow bit directly. If you are going to be using C++, you really should learn assembly.A clean way to do it would be to override all operators (+ and * in particular) and check for an overflow before perorming the operations.@MSalters: Good idea.If the integer calculation is required (for precision), but floating point is available, you could do something like:To expand on Head Geek\'s answer, there is a faster way to do the addition_is_safe;This uses machine-architecture safe, in that 64-bit and 32-bit unsigned integers will still work fine. Basically, I create a mask that will mask out all but the most significant bit. Then, I mask both integers, and if either of them do not have that bit set, then addition is safe.This would be even faster if you pre-initialize the mask in some constructor, since it never changes.x86 instruction set includes unsigned multiply instruction that stores the result to two registers. To use that instruction from C one can write following code in 64bit program (gcc):For 32bit program one needs to make result 64 bit and parameters 32bit.Alternative is to use compiler depend instincts to check the flag register. GCC documentation for overflow instincts can be found from https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.htmlIt depends what you use it for.\nPerforming unsigned long(DWORD) addition or Multiplication\nthe best solution is to use ULARGE_INTEGER.ULARGE_INTEGER is a structure of two DWORDs. The full value\ncan be accessed as "QuadPart" while the hi DWORD is accessed\nas "HighPart" and the low DWORD is accessed as "LowPart"For example:DWORD\nMy Addition(DWORD Value_A,DWORD Value_B)\n{\n ULARGE_INTEGER a,b;// any overflow is stored in a.HighPart(up to 32 bits)The simple way to test for overflow is to do validation by checking whether the current value is less than the previous value.  For example, suppose you had a loop to print the powers of 2:Adding overflow checking the way that I described results in this:It works for unsigned values as well as both positive and negative signed values.Of course, if you wanted to do something similar for decreasing values instead of increasing values, you would flip the <= sign to make it >=, assuming the behaviour of underflow is the same as the behaviour of overflow.  In all honesty, that\'s about as portable as you\'ll get without access to a CPU\'s overflow flag (and that would require inline assembly code, making your code non-portable across implementations anyway).To perform an unsigned multiplication without overflowing in a portable way the following can be used: