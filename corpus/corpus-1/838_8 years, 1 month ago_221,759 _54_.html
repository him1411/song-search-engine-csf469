I want to clear this up once and for all. Can someone please explain the exact meaning of having leading underscores before an object\'s name in Python? Also explain the difference between a single and a double leading underscore. Also, does that meaning stay the same whether the object in question is a variable, a function, a method, etc?Names, in a class, with a leading underscore are simply to indicate to other programmers that the attribute or method is intended to be private.  However, nothing special is done with the name itself.To quote PEP-8:_single_leading_underscore: weak "internal use" indicator. E.g. from M import * does not import objects whose name starts with an underscore.From the Python docs:Any identifier of the form __spam (at least two leading underscores, at most one trailing underscore) is textually replaced with _classname__spam, where classname is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes. And a warning from the same page:Name mangling is intended to give classes an easy way to define \xe2\x80\x9cprivate\xe2\x80\x9d instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; it still is possible for a determined soul to access or modify a variable that is considered private.Excellent answers so far but some tidbits are missing. A single leading underscore isn\'t exactly just a convention: if you use from foobar import *, and module foobar does not define an __all__ list, the names imported from the module do not include those with a leading underscore. Let\'s say it\'s mostly a convention, since this case is a pretty obscure corner;-).The leading-underscore convention is widely used not just for private names, but also for what C++ would call protected ones -- for example, names of methods that are fully intended to be overridden by subclasses (even ones that have to be overridden since in the base class they raise NotImplementedError!-) are often single-leading-underscore names to indicate to code using instances of that class (or subclasses) that said methods are not meant to be called directly.For example, to make a thread-safe queue with a different queueing discipline than FIFO, one imports Queue, subclasses Queue.Queue, and overrides such methods as _get and _put; "client code" never calls those ("hook") methods, but rather the ("organizing") public methods such as put and get (this is known as the Template Method design pattern -- see e.g. here for an interesting presentation based on a video of a talk of mine on the subject, with the addition of synopses of the transcript).__foo__: this is just a convention, a way for the Python system to use names that won\'t conflict with user names._foo: this is just a convention, a way for the programmer to indicate that the variable is private (whatever that means in Python).__foo: this has real meaning: the interpreter replaces this name with _classname__foo as a way to ensure that the name will not overlap with a similar name in another class.No other form of underscores have meaning in the Python world.There\'s no difference between class, variable, global, etc in these conventions.._variable is semiprivate and meant just for convention.__variable is often incorrectly considered superprivate, while it\'s actual meaning is just to namemangle to prevent accidental access[1].__variable__ is typically reserved for builtin methods or variablesYou can still access .__mangled variables if you desperately want to. The double underscores just namemangles, or renames, the variable to something like instance._className__mangledExample:t._b is accessible because it is only hidden by conventiont.__a isn\'t found because it no longer exists due to namemanglingBy accessing instance._className__variable instead of just the double underscore name, you can access the hidden valueSingle underscore at the beginning:Python doesn\'t have real private methods, so one underscore at the start of a method or attribute name means you shouldn\'t access this method, because it\'s not part of the API.code snippet taken from django source code (django/forms/forms.py). This means errors is a property, and it\'s part of the module, but the method this property calls, _get_errors, is "private", so you shouldn\'t access it.Two underscores at the beginning:This causes a lot of confusion. It should not be used to create a private method. It should be used to avoid your method to be overridden by a subclass or accessed accidentally. Let\'s see an example:Output: Now create a subclass B and do customization for __test methodOutput will be....As we have seen, A.test() didn\'t call B.__test() methods, as we might expect. But in fact, this is the correct behavior for __. So when you create a method starting with __ it means that you don\'t want to anyone to be able to override it, it will be accessible only from inside the own class.Two underscores at the beginning and at the end:When we see a method like __this__, don\'t call it. Because it means it\'s a method which python calls, not by you. Let\'s take a look:There is always an operator or native function which calls these magic methods. Sometimes it\'s just a hook python calls in specific situations. For example __init__() is called when the object is created after __new__() is called to build the instance...Let\'s take an example...For more details PEP-8 guide will help more.Please find more magic methods in python here. http://www.rafekettler.com/magicmethods.pdfSometimes you have what appears to be a tuple with a leading underscore as in In this case, what\'s going on is that _() is an alias for a localization function that operates on text to put it into the proper language, etc. based on the locale. For example, Sphinx does this, and you\'ll find among the importsand in sphinx.locale, _() is assigned as an alias of some localization function.If one really wants to make a variable read-only, IMHO the best way would be to use property() with only getter passed to it. With property() we can have complete control over the data.I understand that OP asked a little different question but since I found another question asking for \'how to set private variables\' marked duplicate with this one, I thought of adding this additional info here.Single leading underscores is a convention. there is no difference from the interpreter\'s point of view if whether names starts with a single underscore or not. Double leading and trailing underscores are used for built-in methods, such as __init__, __bool__, etc.Double leading underscores w/o trailing counterparts are a convention too, however, the class methods will be mangled by the interpreter. For variables or basic function names no difference exists.Your question is good, it is not only about methods. Functions and objects in modules are commonly prefixed with one underscore as well, and can be prefixed by two.But __double_underscore names are not name-mangled in modules, for example. What happens is that names beginning with one (or more) underscores are not imported if you import all from a module (from module import *), nor are the names shown in help(module).\xe2\x80\x9cPrivate\xe2\x80\x9d instance variables that cannot be accessed except from inside an object don\xe2\x80\x99t exist in Python. However, there is a convention that is followed by most Python code: a name prefixed with an underscore (e.g. _spam) should be treated as a non-public part of the API (whether it is a function, a method or a data member). It should be considered an implementation detail and subject to change without notice.reference\nhttps://docs.python.org/2/tutorial/classes.html#private-variables-and-class-local-referencesHere is a simple illustrative example on how double underscore properties can affect an inherited class. So with the following setup:if you then create a child instance in the python REPL, you will see the belowThis may be obvious to some, but it caught me off guard in a much more complex environment