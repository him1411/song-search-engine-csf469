For example, if passed the following:How do I check to see if a is empty?Using the implicit booleanness of the empty list is quite pythonic.The pythonic way to do it is from the PEP 8 style guide:For sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n  I prefer it explicitly:This way it\'s 100% clear that li is a sequence (list) and we want to test its size. My problem with if not li: ... is that it gives the false impression that li is a boolean variable.Other people seem to be generalizing your question beyond just lists, so I thought I\'d add a caveat for a different type of sequence that a lot of people might use.  You need to be careful with numpy arrays, because other methods that work fine for lists fail for numpy arrays.  I explain why below, but in short, the preferred method is to use size.The "pythonic" way fails with numpy arrays because numpy tries to cast the array to an array of bools, and if x tries to evaluate all of those bools at once for some kind of aggregate truth value.  But this doesn\'t make any sense, so you get a ValueError:But at least the case above tells you that it failed.  If you happen to have a numpy array with exactly one element, the if statement will "work", in the sense that you don\'t get an error.  However, if that one element happens to be 0 (or 0.0, or false, ...), the if statement will incorrectly result in false:But clearly x exists and is not empty!  This result is not what you wanted.For example,returns 1, even though the array has zero elements.As explained in the scipy FAQ, the correct method in all cases where you know you have a numpy array is to use if x.size:If you\'re not sure whether it might be a list, a numpy array, or something else, you should combine this approach with the answer @dubiousjim gives to make sure the right test is used for each type.  Not very "pythonic", but it turns out that numpy isn\'t pythonic in at least this sense...An empty list is itself considered false in true value testing (see python documentation):@Daren ThomasEDIT: Another point against testing\n  the empty list as False: What about\n  polymorphism? You shouldn\'t depend on\n  a list being a list. It should just\n  quack like a duck - how are you going\n  to get your duckCollection to quack\n  \'\'False\'\' when it has no elements?Your duckCollection should implement __nonzero__ or __len__ so the if a: will work without problems.Patrick\'s (accepted) answer is right: if not a: is the right way to do it. Harley Holcombe\'s answer is right that this is in the PEP 8 style guide. But what none of the answers explain is why it\'s a good idea to follow the idiom\xe2\x80\x94even if you personally find it\'s not explicit enough or confusing to Ruby users or whatever.Python code, and the Python community, has very strong idioms. Following those idioms makes your code easier to read for anyone experienced in Python. And when you violate those idioms, that\'s a strong signal.It\'s true that if not a: doesn\'t distinguish empty lists from None, or numeric 0, or empty tuples, or empty user-created collection types, or empty user-created not-quite-collection types, or single-element NumPy array acting as scalars with falsey values, etc. And sometimes it\'s important to be explicit about that. And in that case, you know what you want to be explicit about, so you can test for exactly that. For example, if not a and a is not None: means "anything falsey except None", while if len(a) != 0: means "only empty sequences\xe2\x80\x94and anything besides a sequence is an error here", and so on. Besides testing for exactly what you want to test, this also signals to the reader that this test is important.But when you don\'t have anything to be explicit about, anything other than if not a: is misleading the reader. You\'re signaling something as important when it isn\'t. (You may also be making the code less flexible, or slower, or whatever, but that\'s all less important.) And if you habitually mislead the reader like this, then when you do need to make a distinction, it\'s going to pass unnoticed because you\'ve been "crying wolf" all over your code.I have seen the below as preferred, as it will catch the null list as well:len() is an O(1) operation for Python lists, strings, dicts, and sets. Python internally keeps track of the number of elements in these containers.JavaScript has a similar notion of truthy/falsy.No one seems to have addressed questioning your need to test the list in the first place.  Because you provided no additional context, I can imagine that you may not need to do this check in the first place, but are unfamiliar with list processing in Python.I would argue that the most pythonic way is to not check at all, but rather to just process the list.  That way it will do the right thing whether empty or full.This has the benefit of handling any contents of a, while not requiring a specific check for emptiness.  If a is empty, the dependent block will not execute and the interpreter will fall through to the next line.If you do actually need to check the array for emptiness, the other answers are sufficient.I had written:which was voted -1. I\'m not sure if that\'s because readers objected to the strategy or thought the answer wasn\'t helpful as presented. I\'ll pretend it was the latter, since---whatever counts as "pythonic"---this is the correct strategy. Unless you\'ve already ruled out, or are prepared to handle cases where a is, for example, False, you need a test more restrictive than just if not a:. You could use something like this:the first test is in response to @Mike\'s answer, above. The third line could also be replaced with:if you only want to accept instances of particular types (and their subtypes), or with:You can get away without the explicit type check, but only if the surrounding context already assures you that a is a value of the types you\'re prepared to handle, or if you\'re sure that types you\'re not prepared to handle are going to raise errors (e.g., a TypeError if you call len on a value for which it\'s undefined) that you\'re prepared to handle. In general, the "pythonic" conventions seem to go this last way. Squeeze it like a duck and let it raise a DuckError if it doesn\'t know how to quack. You still have to think about what type assumptions you\'re making, though, and whether the cases you\'re not prepared to handle properly really are going to error out in the right places. The Numpy arrays are a good example where just blindly relying on len or the boolean typecast may not do precisely what you\'re expecting.Python is very uniform about the treatment of emptiness. Given the following:You simply check list a with an "if" statement to see if it is empty.  From what I have read and been taught, this is the "Pythonic" way to see if a list or tuple is empty.From documentation on truth value testing:All values other than what is listed here are considered TrueAs can be seen, empty list [] is falsy, so doing what would be done to a boolean value sounds most efficient:For example, if passed the following:How do I check to see if a is empty?Place the list in a boolean context (for example, with an if or while statement). It will test False if it is empty, and True otherwise. For example:PEP 8, the official Python style guide for Python code in Python\'s standard library, asserts:For sequences, (strings, lists, tuples), use the fact that empty sequences are false.We should expect that standard library code should be as performant and correct as possible. But why is that the case, and why do we need this guidance?I frequently see code like this from experienced programmers new to Python:And users of lazy languages may be tempted to do this:These are correct in their respective other languages. And this is even semantically correct in Python. But we consider it un-Pythonic because Python supports these semantics directly in the list object\'s interface via boolean coercion.From the docs (and note specifically the inclusion of the empty list, []):By default, an object is considered true unless its class defines\n  either a __bool__() method that returns False or a __len__() method\n  that returns zero, when called with the object. Here are most of the built-in objects considered false:And the datamodel documentation:object.__bool__(self)Called to implement truth value testing and the built-in operation bool(); should return False or True. When this method is not defined,\n  __len__() is called, if it is defined, and the object is considered true if its result is nonzero. If a class defines neither __len__()\n  nor __bool__(), all its instances are considered true.and object.__len__(self)Called to implement the built-in function len(). Should return the length of the object, an integer >= 0. Also, an object that doesn\xe2\x80\x99t define a __bool__() method and whose __len__() method returns zero is considered to be false in a Boolean context.So instead of this:or this:Do this:Does it pay off? (Note that less time to perform an equivalent operation is better:)We see that either checking for length with the builtin function len compared to 0 or checking against an empty list is much less performant than using the builtin syntax of the language as documented.Why?For the len(a) == 0 check:First Python has to check the globals to see if len is shadowed. Then it must call the function, load 0, and do the equality comparison in Python (instead of with C):And for the [] == [] it has to build an unnecessary list and then, again, do the comparison operation in Python\'s virtual machine (as opposed to C)The "Pythonic" way is a much simpler and faster check since the length of the list is cached in the object instance header:PyVarObjectThis is an extension of PyObject that adds the ob_size field. This is only used for objects that have some notion of length. This type does not often appear in the Python/C API. It corresponds to the fields defined by the expansion of the PyObject_VAR_HEAD macro.From the c source in Include/listobject.h:I have enjoyed researching this and I spend a lot of time curating my answers. If you think I\'m leaving something out, please let me know in a comment.Here are a few ways you can check if a list is empty:1) The pretty simple pythonic way:In Python, empty containers such as lists,tuples,sets,dicts,variables etc are seen as False. One could simply treat the list as a predicate (returning a Boolean value). And  a True value would indicate that it\'s non-empty.2) A much explicit way: using the len() to find the length and check if it equals to 0:3) Or comparing it to an anonymous empty list:4) Another yet silly way to do is using exception and iter():some methods what i use:I prefer the following:Readable and you don\'t have to worry about calling a function like len() to iterate through the variable. Although I\'m not entirely sure what the BigO notation of something like this is... but Python\'s so blazingly fast I doubt it\'d matter unless a was gigantic.There is of course alsoprint a or "List is empty"It is sometimes good to test for None and for emptiness separately as those are two different states. The code above produces the following output:Although it\'s worth nothing that None is falsy. So if you don\'t want to separate test for None-ness, you don\'t have to do that. produces expectedYou can even try using bool() like thisI love this way for checking list is empty or not. Very handy and useful.Being inspired by @dubiousjim\'s solution, I propose to use an additional general check of whether is it something iterableNote: a string is considered to be iterable. - add and not isinstance(a,(str,unicode)) if you want the empty string to be excludedTest:Simply use is_empty() or make function like:- It can be used for any data_structure like a list,tuples, dictionary and many more. By these, you can call it many times using just is_empty(any_structure). you can use try and except as it is cheaper than if else construct