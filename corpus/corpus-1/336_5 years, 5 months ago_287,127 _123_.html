Let me prefix this by saying that I know what foreach is, does and how to use it. This question concerns how it works under the bonnet, and I don\'t want any answers along the lines of "this is how you loop an array with foreach".For a long time I assumed that foreach worked with the array itself. Then I found many references to the fact that it works with a copy of the array, and I have since assumed this to be the end of the story. But I recently got into a discussion on the matter, and after a little experimentation found that this was not in fact 100% true.Let me show what I mean. For the following test cases, we will be working with the following array:Test case 1:This clearly shows that we are not working directly with the source array - otherwise the loop would continue forever, since we are constantly pushing items onto the array during the loop. But just to be sure this is the case:Test case 2:This backs up our initial conclusion, we are working with a copy of the source array during the loop, otherwise we would see the modified values during the loop. But...If we look in the manual, we find this statement:When foreach first starts executing, the internal array pointer is automatically reset to the first element of the array.Right... this seems to suggest that foreach relies on the array pointer of the source array. But we\'ve just proved that we\'re not working with the source array, right? Well, not entirely.Test case 3:So, despite the fact that we are not working directly with the source array, we are working directly with the source array pointer - the fact that the pointer is at the end of the array at the end of the loop shows this. Except this can\'t be true - if it was, then test case 1 would loop forever.The PHP manual also states:As foreach relies on the internal array pointer changing it within the loop may lead to unexpected behavior.Well, let\'s find out what that "unexpected behavior" is (technically, any behavior is unexpected since I no longer know what to expect).Test case 4:Test case 5:...nothing that unexpected there, in fact it seems to support the "copy of source" theory.The QuestionWhat is going on here? My C-fu is not good enough for me to able to extract a proper conclusion simply by looking at the PHP source code, I would appreciate it if someone could translate it into English for me.It seems to me that foreach works with a copy of the array, but sets the array pointer of the source array to the end of the array after the loop.foreach supports iteration over three different kinds of values:In the following I will try to explain precisely how iteration works in the different cases. By far the simplest case are Traversable objects, as for these foreach is essentially only syntax sugar for code along these lines:For internal classes actual method calls are avoided by using an internal API that essentially just mirrors the Iterator interface on the C level.Iteration of arrays and plain objects is significantly more complicated. First of all, it should be noted that in PHP "arrays" are really ordered dictionaries and they will be traversed according to this order (which matches the insertion order as long as you didn\'t use something like sort). This is opposed to iterating by the natural order of the keys (how lists in other languages often work) or having no defined order at all (how dictionaries in other languages often work).The same also applies to objects, as the object properties can be seen as another (ordered) dictionary mapping property names to their values, plus some visibility handling. In the majority of cases the object properties are not actually stored in this rather inefficient way. However if you start iterating over an object, the packed representation that is normally used will be converted to a real dictionary. At that point, iteration of plain objects becomes very similar to iteration of arrays (which is why I\'m not discussing plain-object iteration much in here).So far, so good. Iterating over a dictionary can\'t be too hard, right? The problems begin when you realize that an array/object can change during iteration. There are multiple ways this can happen:The problem with allowing modifications during iteration is the case where the element you are currently on is removed. Say you use a pointer to keep track of which array element you are currently at. If this element is now freed, you are left with a dangling pointer (usually resulting in a segfault).There are different ways of solving this issue. PHP 5 and PHP 7 differ significantly in this regard and I\'ll describe both behaviors in the following. The summary is that PHP 5\'s approach was rather dumb and lead to all kinds of weird edge-case issues, while PHP 7\'s more involved approach results in more predictable and consistent behavior.As a last preliminary, it should be noted that PHP uses reference counting and copy-on-write to manage memory. This means that if you "copy" a value, you actually just reuse the old value and increment its reference count (refcount). Only once you perform some kind of modification a real copy (called a "duplication") will be done. See You\'re being lied to for a more extensive introduction on this topic.Arrays in PHP 5 have one dedicated "internal array pointer" (IAP), which properly supports modifications: Whenever an element is removed, there will be a check whether the IAP points to this element. If it does, it is advanced to the next element instead.While foreach does make use of the IAP, there is an additional complication: There is only one IAP, but one array can be be part of multiple foreach loops:To support two simultaneous loops with only one internal array pointer, foreach performs the following schenanigans: Before the loop body is executed, foreach will back up a pointer to the current element and its hash into a per-foreach HashPointer. After the loop body runs, the IAP will be set back to this element if it still exists. If however the element has been removed, we\'ll just use whereever the IAP is currently at. This scheme mostly-kinda-sortof works, but there\'s a lot of weird behavior you can get out of it, some of which I\'ll demonstrate below.The IAP is a visible feature of an array (exposed through the current family of functions), as such changes to the IAP count as modifications under copy-on-write semantics. This unfortunately means that foreach is in many cases forced to duplicate the array it is iterating over. The precise conditions are:If the array is not duplicated (is_ref=0, refcount=1), then only its refcount will be incremented (*). Additionally, if foreach by reference is used, then the (potentially duplicated) array will be turned into a reference.Consider this code as an example where duplication occurs:Here, $arr will be duplicated to prevent IAP changes on $arr from leaking to $outerArr. In terms of the conditions above, the array is not a reference (is_ref=0) and is used in two places (refcount=2). This requirement is unfortunate and an artifact of the suboptimal implementation (there is no concern of modification during iteration here, so we don\'t really need to use the IAP in the first place).(*) Incrementing the refcount here sounds innocuous, but violates copy-on-write (COW) semantics: This means that we are going to modify the IAP of a refcount=2 array, while COW dictates that modifications can only be performed on refcount=1 values. This violation results in user-visible behavior change (while COW is normally transparent), because the IAP change on the iterated array will be observable -- but only until the first non-IAP modification on the array. Instead, the three "valid" options would have been a) to always duplicate, b) to not increment the refcount and thus allowing the iterated array to be arbitrarily modified in the loop, or c) don\'t use the IAP at all (the PHP 7 solution).There is one last implementation detail that you have to be aware of to properly understand the code samples below. The "normal" way of looping through some data structure would look something like this in pseudocode:However foreach, being a rather special snowflake, chooses to do things slightly differently:Namely, the array pointer is already moved forward before the loop body runs. This means that while the loop body is working on element $i, the IAP is already at element $i+1. This is the reason why code samples showing modification during iteration will always unset the next element, rather than the current one.The three aspects described above should provide you with a mostly complete impression of the idiosyncracies of the foreach implementation and we can move on to discussing some examples. The behavior of your test cases is simple to explain at this point:In test cases 1 and 2 $array starts off with refcount=1, so it will not be duplicated by foreach: Only the refcount is incremented. When the loop body subsequently modifies the array (which has refcount=2 at that point), the duplication will occur at that point. Foreach will continue working on an unmodified copy of $array.In test case 3, once again the array is not duplicated, thus foreach will be modifying the IAP of the $array variable. At the end of the iteration the IAP is NULL (meaning iteration done), which each indicates by returning false.In test cases 4 and 5 both each and reset are by-reference functions. The $array has a refcount=2 when it is passed to them, so it has to be duplicated. As such foreach will be working on a separate array again.A good way to show the various duplication behaviors is to observe the behavior of the  current() function inside a foreach loop. Consider this example:Here you should know that current() is a by-ref function (actually: prefer-ref), even though it does not modify the array. It has to be in order to play nice with all the other functions like next which are all by-ref. By-reference passing implies that the array has to be separated and thus $array and the foreach-array will be different. The reason you get 2 instead of 1 is also mentioned above: foreach advances the array pointer before running the user code, not after. So even though the code is at the first element, foreach already advanced the pointer to the second.Now lets try a small modification:Here we have the is_ref=1 case, so the array is not copied (just like above). But now that it is a reference, the array no longer has to be duplicated when passing to the by-ref current() function. Thus current() and foreach work on the same array. You still see the off-by-one behavior though, due to the way foreach advances the pointer.You get the same behavior when doing by-ref iteration:Here the important part is that foreach will make $array an is_ref=1 when it is iterated by reference, so basically you have the same situation as above.Another small variation, this time we\'ll assign the array to another variable:Here the refcount of the $array is 2 when the loop is started, so for once we actually have to do the duplication upfront. Thus $array and the array used by foreach will be completely separate from the outset. That\'s why you get the position of the IAP wherever it was before the loop (in this case it was at the first position).Trying to account for modifications during iteration is where all our foreach troubles originated, so it serves to consider some examples for this case.Consider these nested loops over the same array (where by-ref iteration is used to make sure it really is the same one):The expected part here is that (1, 2) is missing from the output, because element 1 was removed. What\'s probably unexpected is that the outer loop stops after the first element. Why is that?The reason behind this is the nested-loop hack described above: Before the loop body runs, the current IAP position and hash is backed up into a HashPointer. After the loop body it will be restored, but only if the element still exists, otherwise the current IAP position (whatever it may be) is used instead. In the example above this is exactly the case: The current element of the outer loop has been remove, so it will use the IAP, which has already been marked as finished by the inner loop!Another consequence of the HashPointer backup+restore mechanism is that changes to the IAP though reset() etc. usually do not impact foreach. For example, the following code executes as if the reset() were not present at all:The reason is that, while reset() temporarily modifies the IAP, it will be restored to the current foreach element after the loop body. To force reset() to make an effect on the loop, you have to additionally remove the current element, so that the backup/restore mechanism fails:But, those examples are still sane. The real fun starts if you remember that the HashPointer restore uses a pointer to the element and its hash to determine whether it still exists. But: Hashes have collisions, and pointers can be reused! This means that, with a careful choice of array keys, we can make foreach believe that an element that has been removed still exists, so it will jump directly to it. An example:Here we should normally expect the output 1, 1, 3, 4 according to the previous rules. How what happens is that \'FYFY\' has the same hash as the removed element \'EzFY\', and the allocator happens to reuse the same memory location to store the element. So foreach ends up directly jumping to the newly inserted element, thus short-cutting the loop.One last odd case that I\'d like to mention, is is that PHP allows you to substitute the iterated entity during the loop. So you can start iterating on one array and then replace it with another array halfway through. Or start iterating on an array and then replace it with an object:As you can see in this case PHP will just start iterating the other entity from the start once the substitution has happened.If you still remember, the main problem with array iteration was how to handle removal of elements mid-iteration. PHP 5 used a single internal array pointer (IAP) for this purpose, which was somewhat suboptimal, as one array pointer had to be stretched to support multiple simultaneous foreach loops and interaction with reset() etc. on top of that.PHP 7 uses a different approach, namely it supports creating an arbitrary amount of external, safe hashtable iterators. These iterators have to be registered in the array, from which point on they have the same semantics as the IAP: If an array element is removed, all hashtable iterators pointing to that element will be advanced to the next element.This means that foreach will no longer use the IAP at all. The foreach loop will be absolutely no effect on the results of current() etc. and its own behavior will never be influence by functions like  reset() etc.Another important change between PHP 5 and PHP 7 relates to array duplication. Now that the IAP is no longer used, by-value array iteration will only do a refcount increment (instead of duplication the array) in all cases. If the array is modified during the foreach loop, at that point a duplication will occur (according to copy-on-write) and foreach will keep working on the old array.In most cases this change is transparent and has no other effect than better performance. However there is one occasion where it results in different behavior, namely the case where the array was a reference beforehand:Previously by-value iteration of reference-arrays was special cases. In this case no duplication occurred, so all modifications of the array during iteration would be reflected by the loop. In PHP 7 this special case is gone: A by-value iteration of an array will always keep working on the original elements, disregarding any modifications during the loop.This, of course, does not apply to by-reference iteration. If you iterate by-reference all modifications will be reflected by the loop. Interestingly, the same is true for by-value iteration of plain objects:This reflects by-handle semantics of objects (i.e. they behave reference-like even in by-value contexts).Lets consider a few examples, starting with your test cases:Test cases 1 and 2 retain the same output: By-value array iteration always keeps working on the original elements. (In this case even refcounting and duplication behavior is exactly the same between PHP 5 and PHP 7).Test case 3 changes: Foreach no longer uses the IAP, so each() is not affected by the loop. It will have the same output before and after.Test cases 4 and 5 stay the same: each() and reset() will duplicate the array before changing the IAP, while foreach still uses the original array. (Not that the IAP change would have mattered, even if the array was shared.)The second set of examples was related to the behavior of current() under different reference/refcounting configurations. This no longer makes sense, as current() is completely unaffected by the loop, so its return value always stays the same.However, we get some interesting changes when considering modifications during iteration. I hope you will find the new behavior more sane. The first example:As you can see, the outer loop no longer aborts after the first iteration. The reason is that both loops now have entirely separate hashtable iterators, and there is no longer any cross-contamination of both loops through a shared IAP.Another weird edge case that is fixed now, is the odd effect you get when you remove and add elements that happen to have the same hash:Previously the HashPointer restore mechanism jumped right to the new element, because it "looked" like it\'s the same as the remove element (due to colliding hash and pointer). As we no longer rely on the element hash for anything, this is no longer an issue.In example 3 you don\'t modify the array. In all other examples you modify either the contents or the internal array pointer. This is important when it comes to PHP arrays because of the semantics of the assignment operator.The assignment operator for the arrays in PHP works more like a lazy clone. Assigning one variable to another that contains an array will clone the array, unlike most languages. However, the actual cloning will not be done unless it is needed. This means that the clone will take place only when either of the variables is modified (copy-on-write).Here is an example:Coming back to your test cases, you can easily imagine that foreach creates some kind of iterator with a reference to the array. This reference works exactly like the variable $b in my example. However, the iterator along with the reference live only during the loop and then, they are both discarded. Now you can see that, in all cases but 3, the array is modified during the loop, while this extra reference is alive. This triggers a clone, and that explains what\'s going on here!Here is an excellent article for another side effect of this copy-on-write behaviour: The PHP Ternary Operator: Fast or not?Some points to note when working with foreach():a) foreach works on the prospected copy of the original array.\n    It means foreach() will have SHARED data storage until or unless a prospected copy is\n    not created foreach Notes/User comments.b) What triggers a prospected copy?\n    Prospected copy is created based on the policy of copy-on-write, that is, whenever\n    an array passed to foreach() is changed, a clone of original array is created.c) The original array and foreach() iterator will have DISTINCT SENTINEL VARIABLES, that is, one for the original array and other for foreach; see the test code below. SPL , Iterators, and Array Iterator.StackÂ Overflow question How to make sure the value is reset in a \'foreach\' loop in PHP? addresses the  cases (3,4,5) of your question.The following example show that each() and reset() DOES NOT affect SENTINEL variables\n(for example, the current index variable) of the foreach() iterator.Output:Explanation (quote from php.net):The first form loops over the array given by array_expression. On each\n  iteration, the value of the current element is assigned to $value and\n  the internal array pointer is advanced by one (so on the next\n  iteration, you\'ll be looking at the next element).So, in your first example you only have one element in the array, and when the pointer is moved the next element does not exist, so after you add new element foreach ends because it already "decided" that it it as the last element.In your second example, you start with two elements, and foreach loop is not at the last element so it evaluates the array on the next iteration and thus realises that there is new element in the array.I believe that this is all consequence of On each iteration part of the explanation in the documentation, which probably means that foreach does all logic before it calls the code in {}.Test caseIf you run this:You will get this output: Which means that it accepted the modification and went through it because it was modified "in time". But if you do this:You will get:Which means that array was modified, but since we modified it when the foreach already was at the last element of the array, it "decided" not to loop anymore, and even though we added new element, we added it "too late" and it was not looped through.Detailed explanation can be read at How does PHP 'foreach' actually work? which explains the internals behind this behaviour.As per the documentation provided by PHP manual.On each iteration, the value of the current element is assigned to $v and the internal\n  array pointer is advanced by one (so on the next iteration, you\'ll be looking at the next element).So as per your first example:   $array have only single element, so as per the foreach execution, 1 assign to $v and it don\'t have any other element to move pointerBut in your second example:$array have two element, so now $array evaluate the zero indices and move the pointer by one. For first iteration of loop, added $array[\'baz\']=3; as pass by reference.Great question, because many developers, even experienced ones, are confused by the way PHP handles arrays in foreach loops. In the standard foreach loop, PHP makes a copy of the array that is used in the loop. The copy is discarded immediately after the loop finishes. This is transparent in the operation of a simple foreach loop. \nFor example:This outputs:So the copy is created but the developer doesn\'t notice, because the original array isn\xe2\x80\x99t referenced within the loop or after the loop finishes. However, when you attempt to modify the items in a loop, you find that they are unmodified when you finish:This outputs:Any changes from the original can\'t be notices, actually there are no changes from the original, even though you clearly assigned a value to $item. This is because you are operating on $item as it appears in the copy of $set being worked on. You can override this by grabbing $item by reference, like so:This outputs:So it is evident and observable, when $item is operated on by-reference, the changes made to $item are made to the members of the original $set. Using $item by reference also prevents PHP from creating the array copy. To test this, first we\xe2\x80\x99ll show a quick script demonstrating the copy:This outputs:As it is shown in the example, PHP copied $set and used it to loop over, but when $set was used inside the loop, PHP added the variables to the original array, not the copied array. Basically, PHP is only using the copied array for the execution of the loop and the assignment of $item. Because of this, the loop above only executes 3 times, and each time it appends another value to the end of the original $set, leaving the original $set with 6 elements, but never entering an infinite loop.However, what if we had used $item by reference, as I mentioned before? A single character added to the above test:Results in an infinite loop. Note this actually is an infinite loop, you\xe2\x80\x99ll have to either kill the script yourself or wait for your OS to run out of memory. I added the following line to my script so PHP would run out of memory very quickly, I suggest you do the same if you\xe2\x80\x99re going to be running these infinite loop tests:So in this previous example with the infinite loop, we see the reason why PHP was written to create a copy of the array to loop over. When a copy is created and used only by the structure of the loop construct itself, the array stays static throughout the execution of the loop, so you\xe2\x80\x99ll never run into issues.