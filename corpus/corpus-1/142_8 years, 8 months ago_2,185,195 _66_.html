If I create a global variable in one function, how can I use that variable in another function?\nDo I need to store the global variable in a local variable of the function which needs its access?You can use a global variable in other functions by declaring it as global in each function that assigns to it:I imagine the reason for it is that, since global variables are so dangerous, Python wants to make sure that you really know that\'s what you\'re playing with by explicitly requiring the global keyword.See other answers if you want to share a global variable across modules.If I\'m understanding your situation correctly, what you\'re seeing is the result of how Python handles local (function) and global (module) namespaces.Say you\'ve got a module like this:You might expecting this to print 42, but instead it prints 5.  As has already been mentioned, if you add a \'global\' declaration to func1(), then func2() will print 42.What\'s going on here is that Python assumes that any name that is assigned to, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only reading from a name, and the name doesn\'t exist locally, it will try to look up the name in any containing scopes (e.g. the module\'s global scope).When you assign 42 to the name myGlobal, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is garbage-collected when func1() returns; meanwhile, func2() can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of myGlobal inside func1() before you assign to it, you\'d get an UnboundLocalError, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the \'global\' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.(I believe that this behavior originated largely through an optimization of local namespaces -- without this behavior,  Python\'s VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn\'t already exist at module/builtin level), which would significantly slow down a very common operation.)You may want to explore the notion of namespaces. In Python, the module is the natural place for global data:Each module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user\xe2\x80\x99s global variables. On the other hand, if you know what you are doing you can touch a module\xe2\x80\x99s global variables with the same notation used to refer to its functions, modname.itemname.A specific use of global-in-a-module is described here - how-do-i-share-global-variables-across-modules:The canonical way to share information across modules within a single program is to create a special configuration module (often called config or cfg). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:File: config.pyFile: mod.pyFile: main.pyPython uses a simple heuristic to decide which scope it should load a variable from, between local and global.  If a variable name appears on the left hand side of an assignment, but is not declared global, it is assumed to be local.  If it does not appear on the left hand side of an assignment, it is assumed to be global.  See how baz, which appears on the left side of an assignment in foo(), is the only LOAD_FAST variable.If you want to refer to a global variable in a function, you can use the global keyword to declare which variables are global. You don\'t have to use it in all cases (as someone here incorrectly claims) - if the name referenced in an expression cannot be found in local scope or scopes in the functions in which this function is defined, it is looked up among global variables.However, if you assign to a new variable not declared as global in the function, it is implicitly declared as local, and it can overshadow any existing global variable with the same name.Also, global variables are useful, contrary to some OOP zealots who claim otherwise - especially for smaller scripts, where OOP is overkill.In addition to already existing answers and to make this more confusing:In Python, variables that are only referenced inside a function are\n  implicitly global. If a variable is assigned a new value anywhere\n  within the function\xe2\x80\x99s body, it\xe2\x80\x99s assumed to be a local. If a variable\n  is ever assigned a new value inside the function, the variable is\n  implicitly local, and you need to explicitly declare it as \xe2\x80\x98global\xe2\x80\x99.Though a bit surprising at first, a moment\xe2\x80\x99s consideration explains\n  this. On one hand, requiring global for assigned variables provides a\n  bar against unintended side-effects. On the other hand, if global was\n  required for all global references, you\xe2\x80\x99d be using global all the\n  time. You\xe2\x80\x99d have to declare as global every reference to a built-in\n  function or to a component of an imported module. This clutter would\n  defeat the usefulness of the global declaration for identifying\n  side-effects.Source: What are the rules for local and global variables in Python?.With parallel execution, global variables can cause unexpected results if you don\'t understand what is happening. Here is an example of using a global variable within multiprocessing. We can clearly see that each process works with its own copy of the variable:Output:We can create a global with the following function:Writing a function does not actually run its code. So we call the create_global_variable function:You can just use it, so long as you don\'t expect to change which object it points to: For example, and now we can use the global variable:To point the global variable at a different object, you are required to use the global keyword again:Note that after writing this function, the code actually changing it has still not run:So after calling the function:we can see that the global variable has been changed. The global_variable name now points to \'Bar\':Note that "global" in Python is not truly global - it\'s only global to the module level. So it is only available to functions written in the modules in which it is global. Functions remember the module in which they are written, so when they are exported into other modules, they still look in the module in which they were created to find global variables.If you create a local variable with the same name, it will overshadow a global variable:But using that misnamed local variable does not change the global variable:Note that you should avoid using the local variables with the same names as globals unless you know precisely what you are doing and have a very good reason to do so. I have not yet encountered such a reason.You\'re not actually storing the global in a local variable, just creating a local reference to the same object that your original global reference refers to. Remember that pretty much everything in Python is a name referring to an object, and nothing gets copied in usual operation.If you didn\'t have to explicitly specify when an identifier was to refer to a predefined global, then you\'d presumably have to explicitly specify when an identifier is a new local variable instead (for example, with something like the \'var\' command seen in JavaScript). Since local variables are more common than global variables in any serious and non-trivial system, Python\'s system makes more sense in most cases.You could have a language which attempted to guess, using a global variable if it existed or creating a local variable if it didn\'t. However, that would be very error-prone. For example, importing another module could inadvertently introduce a global variable by that name, changing the behaviour of your program.You need to reference the global variable in every function you want to use.As follows:As it turns out the answer is always simple.Here is a small sample module. It is is a way to show it in a main definition:Here is a way to show it in a main definition:This simple code works just like that, and it will execute. I hope it helps.What you are saying is to use the method like this:But the better way is to use the global variable like this:Both give the same output.Try this:Writing to explicit elements of a global array does not apparently need the global declaration, though writing to it "wholesale" does have that requirement:Following on and as an add on, use a file to contain all global variables all declared locally and then \'import as\':.....In case you have a local variable with the same name, you might want to use the globals() function.Reference the class namespace where you want the change to show up.  In this example, runner is using max from the file config. I want my test to change the value of max when runner is using it.main/config.pymain/runner.pytests/runner_test.pyI\'m adding this as I haven\'t seen it in any of the other answers and it might be useful for someone struggling with something similar. The globals() function returns a mutable global symbol dictionary where you can "magically" make data available for the rest of your code. \nFor example:and Will just let you dump/load variables out of and into the global namespace. Super convenient, no muss, no fuss. Pretty sure it\'s python 3 only.