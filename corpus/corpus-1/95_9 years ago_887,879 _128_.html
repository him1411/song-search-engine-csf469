I have two Python dictionaries, and I want to write a single expression that returns these two dictionaries, merged.  The update() method would be what I need, if it returned its result instead of modifying a dict in-place.How can I get that final merged dict in z, not x?(To be extra-clear, the last-one-wins conflict-handling of dict.update() is what I\'m looking for as well.)Say you have two dicts and you want to merge them into a new dict without altering the original dicts:The desired result is to get a new dictionary (z) with the values merged, and the second dict\'s values overwriting those from the first.A new syntax for this, proposed in PEP 448 and available as of Python 3.5, is And it is indeed a single expression. It is now showing as implemented in the release schedule for 3.5, PEP 478, and it has now made its way into What\'s New in Python 3.5 document.However, since many organizations are still on Python 2, you may wish to do this in a backwards compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:In both approaches, y will come second and its values will replace x\'s values, thus \'b\' will point to 3 in our final result.If you are not yet on Python 3.5, or need to write backward-compatible code, and you want this in a single expression, the most performant while correct approach is to put it in a function:and then you have a single expression:You can also make a function to merge an undefined number of dicts, from zero to a very large number:This function will work in Python 2 and 3 for all dicts. e.g. given dicts a to g:and key value pairs in g will take precedence over dicts a to f, and so on.Don\'t use what you see in the formerly accepted answer:In Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. In Python 3, this will fail because you\'re adding two dict_items objects together, not two lists - and you would have to explicitly create them as lists, e.g. z = dict(list(x.items()) + list(y.items())). This is a waste of resources and computation power. Similarly, taking the union of items() in Python 3 (viewitems() in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, since sets are semantically unordered, the behavior is undefined in regards to precedence. So don\'t do this:This example demonstrates what happens when values are unhashable:Here\'s an example where y should have precedence, but instead the value from x is retained due to the arbitrary order of sets:Another hack you should not use:This uses the dict constructor, and is very fast and memory efficient (even slightly more-so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it\'s difficult to read, it\'s not the intended usage, and so it is not Pythonic. Here\'s an example of the usage being remediated in django.Dicts are intended to take hashable keys (e.g. frozensets or tuples), but this method fails in Python 3 when keys are not strings.From the mailing list, Guido van Rossum, the creator of the language, wrote:I am fine with\n  declaring dict({}, **{1:3}) illegal, since after all it is abuse of\n  the ** mechanism.and Apparently dict(x, **y) is going around as "cool hack" for "call\n  x.update(y) and return x". Personally I find it more despicable than\n  cool.It is my understanding (as well as the understanding of the creator of the language) that the intended usage for dict(**y) is for creating dicts for readability purposes, e.g.:instead of Despite what Guido says, dict(x, **y) is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-comming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact ** was designed precisely to pass dicts as keywords. Again, it doesn\'t work for 3 when keys are non-strings. The implicit calling contract is that namespaces take ordinary dicts, while users must only pass keyword arguments that are strings. All other callables enforced it. dict broke this consistency in Python 2:This inconsistency was bad given other implementations of Python (Pypy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.I submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.These approaches are less performant, but they will provide correct behavior.\nThey will be much less performant than copy and update or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they do respect the order of precedence (latter dicts have precedence)You can also chain the dicts manually inside a dict comprehension:or in python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):itertools.chain will chain the iterators over the key-value pairs in the correct order:I\'m only going to do the performance analysis of the usages known to behave correctly. The following is done on Ubuntu 14.04In Python 2.7 (system Python):In Python 3.5 (deadsnakes PPA):In your case, what you can do is:This will, as you want it, put the final dict in z, and make the value for key b be properly overridden by the second (y) dict\'s value:If you use Python 3, it is only a little more complicated.  To create z:An alternative:Another, more concise, option:Note: this has become a popular answer, but it is important to point out that if y has any non-string keys, the fact that this works at all is an abuse of a CPython implementation detail, and it does not work in Python 3, or in PyPy, IronPython, or Jython. Also, Guido is not a fan. So I can\'t recommend this technique for forward-compatible or cross-implementation portable code, which really means it should be avoided entirely.This probably won\'t be a popular answer, but you almost certainly do not want to do this.  If you want a copy that\'s a merge, then use copy (or deepcopy, depending on what you want) and then update.  The two lines of code are much more readable - more Pythonic - than the single line creation with .items() + .items().  Explicit is better than implicit.In addition, when you use .items() (pre Python 3.0), you\'re creating a new list that contains the items from the dict.  If your dictionaries are large, then that is quite a lot of overhead (two large lists that will be thrown away as soon as the merged dict is created).  update() can work more efficiently, because it can run through the second dict item-by-item.In terms of time:IMO the tiny slowdown between the first two is worth it for the readability.  In addition, keyword arguments for dictionary creation was only added in Python 2.3, whereas copy() and update() will work in older versions.In a follow-up answer, you asked about the relative performance of these two alternatives:On my machine, at least (a fairly ordinary x86_64 running Python 2.5.2), alternative z2 is not only shorter and simpler but also significantly faster.  You can verify this for yourself using the timeit module that comes with Python.Example 1: identical dictionaries mapping 20 consecutive integers to themselves:z2 wins by a factor of 3.5 or so.  Different dictionaries seem to yield quite different results, but z2 always seems to come out ahead.  (If you get inconsistent results for the same test, try passing in -r with a number larger than the default 3.)Example 2: non-overlapping dictionaries mapping 252 short strings to integers and vice versa:z2 wins by about a factor of 10.  That\'s a pretty big win in my book!After comparing those two, I wondered if z1\'s poor performance could be attributed to the overhead of constructing the two item lists, which in turn led me to wonder if this variation might work better:A few quick tests, e.g.lead me to conclude that z3 is somewhat faster than z1, but not nearly as fast as z2.  Definitely not worth all the extra typing.This discussion is still missing something important, which is a performance comparison of these alternatives with the "obvious" way of merging two lists: using the update method.  To try to keep things on an equal footing with the expressions, none of which modify x or y, I\'m going to make a copy of x instead of modifying it in-place, as follows:A typical result:In other words, z0 and z2 seem to have essentially identical performance.  Do you think this might be a coincidence?  I don\'t....In fact, I\'d go so far as to claim that it\'s impossible for pure Python code to do any better than this.  And if you can do significantly better in a C extension module, I imagine the Python folks might well be interested in incorporating your code (or a variation on your approach) into the Python core.  Python uses dict in lots of places; optimizing its operations is a big deal.You could also write this asas Tony does, but (not surprisingly) the difference in notation turns out not to have any measurable effect on performance.  Use whichever looks right to you.  Of course, he\'s absolutely correct to point out that the two-statement version is much easier to understand.I wanted something similar, but with the ability to specify how the values on duplicate keys were merged, so I hacked this out (but did not heavily test it).  Obviously this is not a single expression, but it is a single function call.In Python 3, you can use collections.ChainMap which groups multiple dicts or other mappings together to create a single, updateable view:The best version I could think while not using copy would be:It\'s faster than dict(x.items() + y.items()) but not as fast as n = copy(a); n.update(b), at least on CPython. This version also works in Python 3 if you change iteritems() to items(), which is automatically done by the 2to3 tool.Personally I like this version best because it describes fairly good what I want in a single  functional syntax. The only minor problem is that it doesn\'t make completely obvious that values from y takes precedence over values from x, but I don\'t believe it\'s difficult to figure that out.Demonstration:Outputs:Thanks rednaw for edits.For items with keys in both dictionaries (\'b\'), you can control which one ends up in the output by putting that one last.Python 3.5 (PEP 448) allows a nicer syntax option:Or even While the question has already been answered several times,\nthis simple solution to the problem has not been listed yet.It is as fast as z0 and the evil z2 mentioned above, but easy to understand and change.Among such shady and dubious answers, this shining example is the one and only good way to merge dicts in Python, endorsed by dictator for life Guido van Rossum himself!  Someone else suggested half of this, but did not put it in a function.gives:If you think lambdas are evil then read no further.\nAs requested, you can write the fast and memory-efficient solution with one expression:As suggested above, using two lines or writing a function is probably a better way to go.In python3, the items method no longer returns a list, but rather a view, which acts like a set. In this case you\'ll need to take the set union since concatenating with + won\'t work:For python3-like behavior in version 2.7, the viewitems method should work in place of items:I prefer this notation anyways since it seems more natural to think of it as a set union operation rather than concatenation (as the title shows).Edit:A couple more points for python 3. First, note that the dict(x, **y) trick won\'t work in python 3 unless the keys in y are strings.Also, Raymond Hettinger\'s Chainmap answer is pretty elegant, since it can take an arbitrary number of dicts as arguments, but from the docs it looks like it sequentially looks through a list of all the dicts for each lookup:Lookups search the underlying mappings successively until a key is found.This can slow you down if you have a lot of lookups in your application:So about an order of magnitude slower for lookups. I\'m a fan of Chainmap, but looks less practical where there may be many lookups.Abuse leading to a one-expression solution for Matthew\'s answer:You said you wanted one expression, so I abused lambda to bind a name, and tuples to override lambda\'s one-expression limit. Feel free to cringe.You could also do this of course if you don\'t care about copying it:Simple solution using itertools that preserves order (latter dicts have precedence)And it\'s usage:Be pythonic. Use a comprehension:Even though the answers were good for this shallow dictionary, none of the methods defined here actually do a deep dictionary merge.Examples follow:One would expect a result of something like this:Instead, we get this:The \'one\' entry should have had \'depth_2\' and \'extra\' as items inside its dictionary if it truly was a merge.Using chain also, does not work:Results in:The deep merge that rcwesick gave also creates the same result.Yes, it will work to merge the sample dictionaries, but none of them are a generic mechanism to merge.  I\'ll update this later once I write a method that does a true merge.Two dictionariesn dictionariessum has bad performance. See https://mathieularose.com/how-not-to-flatten-a-list-of-lists-in-python/Drawing on ideas here and elsewhere I\'ve comprehended a function:Usage (tested in python 3):You could use a lambda instead.The problem I have with solutions listed to date is that, in the merged dictionary, the value for key "b" is 10 but, to my way of thinking, it should be 12.\nIn that light, I present the following:For Python 2 :For Python 3:It gives output:{\'a\': 1, \'c\': 11, \'b\': 10}You can use toolz.merge([x, y]) for this.In python 3:Out:Docs: https://docs.python.org/3/library/collections.html#collections.ChainMap:Using  a dict comprehension, you maygivesNote the syntax for if else in comprehension This can be done with a single dict comprehension:In my view the best answer for the \'single expression\' part as no extra functions are needed, and it is short.This should solve your problem.