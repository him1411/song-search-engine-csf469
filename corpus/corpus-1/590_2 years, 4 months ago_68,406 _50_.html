It is my understanding that the range() function, which is actually an object type in Python 3, generates its contents on the fly, similar to a generator. This being the case, I would have expected the following line to take an inordinate amount of time, because in order to determine whether 1 quadrillion is in the range, a quadrillion values would have to be generated: Furthermore: it seems that no matter how many zeroes I add on, the calculation more or less takes the same amount of time (basically instantaneous). I have also tried things like this, but the calculation is still almost instant: If I try to implement my own range function, the result is not so nice!! What is the range() object doing under the hood that makes it so fast? EDIT: This has turned out to be a much more nuanced topic than I anticipated - there seems to be a bit of history behind the optimization of range(). Martijn Pieters\' answer was chosen for its completeness, but also see abarnert\'s first answer for a good discussion of what it means for range to be a full-fledged sequence in Python 3, and some information/warning regarding potential inconsistency for __contains__ function optimization across Python implementations. abarnert\'s other answer goes into some more detail and provides links for those interested in the history behind the optimization in Python 3 (and lack of optimization of xrange in Python 2). Answers by poke and by wim provide the relevant C source code and explanations for those who are interested. The Python 3 range() object doesn\'t produce numbers immediately; it is a smart sequence object that produces numbers on demand. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.The object also implements the object.__contains__ hook, and calculates if your number is part of its range. Calculating is a O(1) constant time operation. There is never a need to scan through all possible integers in the range.From the range() object documentation:The advantage of the range type over a regular list or tuple is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the start, stop and step values, calculating individual items and subranges as needed).So at a minimum, your range() object would do:This is still missing several things that a real range() supports (such as the .index() or .count() methods, hashing, equality testing, or slicing), but should give you an idea.I also simplified the __contains__ implementation to only focus on integer tests; if you give a real range() object a non-integer value (including subclasses of int), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original Python issue that implemented the containment test.The fundamental misunderstanding here is in thinking that range is a generator. It\'s not. In fact, it\'s not any kind of iterator.You can tell this pretty easily:If it were a generator, iterating it once would exhaust it:What range actually is, is a sequence, just like a list. You can even test this:This means it has to follow all the rules of being a sequence:The difference between a range and a list is that a range is a lazy or dynamic sequence; it doesn\'t remember all of its values, it just remembers its start, stop, and step, and creates the values on demand on __getitem__.(As a side note, if you print(iter(a)), you\'ll notice that range uses the same listiterator type as list. How does that work? A listiterator doesn\'t use anything special about list except for the fact that it provides a C implementation of __getitem__, so it works fine for range too.)Now, there\'s nothing that says that Sequence.__contains__ has to be constant time\xe2\x80\x94in fact, for obvious examples of sequences like list, it isn\'t. But there\'s nothing that says it can\'t be. And it\'s easier to implement range.__contains__ to just check it mathematically ((val - start) % step, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why shouldn\'t it do it the better way?But there doesn\'t seem to be anything in the language that guarantees this will happen. As Ashwini Chaudhari points out, if you give it a non-integral value, instead of converting to integer and doing the mathematical test, it will fall back to iterating all the values and comparing them one by one. And just because CPython 3.2+ and PyPy 3.x versions happen to contain this optimization, and it\'s an obvious good idea and easy to do, there\'s no reason that IronPython or NewKickAssPython 3.x couldn\'t leave it out. (And in fact CPython 3.0-3.1 didn\'t include it.)If range actually were a generator, like my_crappy_range, then it wouldn\'t make sense to test __contains__ this way, or at least the way it makes sense wouldn\'t be obvious. If you\'d already iterated the first 3 values, is 1 still in the generator? Should testing for 1 cause it to iterate and consume all the values up to 1 (or up to the first value >= 1)?Use the source, Luke!In CPython, range(...).__contains__ (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.  The reason for the speed here is we\'re using mathematical reasoning about the bounds, rather than a direct iteration of the range object.  To explain the logic used: For example, 994 is in range(4, 1000, 2) because:The full C code is included below, which is a bit more verbose because of memory management and reference counting details, but the basic idea is there:The "meat" of the idea is mentioned in the line:As a final note - look at the range_contains function at the bottom of the code snippet.  If the exact type check fails then we don\'t use the clever algorithm described, instead falling back to a dumb iteration search of the range using _PySequence_IterSearch!  You can check this behaviour in the interpreter (I\'m using v3.5.0 here):To add to Martijn\xe2\x80\x99s answer, this is the relevant part of the source (in C, as the range object is written in native code):So for PyLong objects (which is int in Python 3), it will use the range_contains_long function to determine the result. And that function essentially checks if ob is in the specified range (although it looks a bit more complex in C).If it\xe2\x80\x99s not an int object, it falls back to iterating until it finds the value (or not).The whole logic could be translated to pseudo-Python like this:If you\'re wondering why this optimization was added to range.__contains__, and why it wasn\'t added to xrange.__contains__ in 2.7:First, as Ashwini Chaudhary discovered, issue 1766304 was opened explicitly to optimize [x]range.__contains__. A patch for this was accepted and checked in for 3.2, but not backported to 2.7 because "xrange has behaved like this for such a long time that I don\'t see what it buys us to commit the patch this late." (2.7 was nearly out at that point.)Meanwhile:Originally, xrange was a not-quite-sequence object. As the 3.1 docs say:Range objects have very little behavior: they only support indexing, iteration, and the len function.This wasn\'t quite true; an xrange object actually supported a few other things that come automatically with indexing and len,* including __contains__ (via linear search). But nobody thought it was worth making them full sequences at the time.Then, as part of implementing the Abstract Base Classes PEP, it was important to figure out which builtin types should be marked as implementing which ABCs, and xrange/range claimed to implement collections.Sequence, even though it still only handled the same "very little behavior". Nobody noticed that problem until issue 9213. The patch for that issue not only added index and count to 3.2\'s range, it also re-worked the optimized __contains__ (which shares the same math with index, and is directly used by count).** This change went in for 3.2 as well, and was not backported to 2.x, because "it\'s a bugfix that adds new methods". (At this point, 2.7 was already past rc status.)So, there were two chances to get this optimization backported to 2.7, but they were both rejected.* In fact, you even get iteration for free with len and indexing, but in 2.3 xrange objects got a custom iterator. Which they then lost in 3.x, which uses the same listiterator type as list.** The first version actually reimplemented it, and got the details wrong\xe2\x80\x94e.g., it would give you MyIntSubclass(2) in range(5) == False. But Daniel Stutzbach\'s updated version of the patch restored most of the previous code, including the fallback to the generic, slow _PySequence_IterSearch that pre-3.2 range.__contains__ was implicitly using when the optimization doesn\'t apply.The other answers explained it well already, but I\'d like to offer another experiment illustrating the nature of range objects:As you can see,  a range object is an object that remembers its range and can be used many times (even while iterating over it), not just a one-time generator.In python 3.x .When you use the range function then you have to take the parameters as "for i in range(parameters)".\nwhen you takes the parametrs then that parameters range starting from 0th position. If you want to print the numbers upto 1000000000000001 then normally it prints till 1000000000000000.Because it also consider the 0th position.\nthe solution to your problem as follws:`This code implement as if you want to print numbers from 1 to 1000000000000001 including 1000000000000001 then at the time of you taking the input you have to enter the number 1000000000000001.It prints the numbers includeng 1000000000000001.\nFor example:Output: