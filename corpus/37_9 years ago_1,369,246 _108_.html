What is the most efficient way to clone a JavaScript object? I\'ve seen obj = eval(uneval(o)); being used, but that\'s non-standard and only supported by Firefox. I\'ve done things like obj = JSON.parse(JSON.stringify(o)); but question the efficiency.  I\'ve also seen recursive copying functions with various flaws.\n\nI\'m surprised no canonical solution exists.Note: This is a reply to another answer, not a proper response to this question. If you wish to have fast object cloning please follow Corban\'s advice in their answer to this question.I want to note that the .clone() method in jQuery only clones DOM elements. In order to clone JavaScript objects, you would do:More information can be found in the jQuery documentation.I also want to note that the deep copy is actually much smarter than what is shown above \xe2\x80\x93 it\'s able to avoid many traps (trying to deep extend a DOM element, for example). It\'s used frequently in jQuery core and in plugins to great effect.Checkout this benchmark: http://jsben.ch/#/bWfk9In my previous tests where speed was a main concern I found to be the fastest way to deep clone an object (it beats out jQuery.extend with deep flag set true by 10-20%).jQuery.extend is pretty fast when the deep flag is set to false (shallow clone). It is a good option, because it includes some extra logic for type validation and doesn\'t copy over undefined properties, etc., but this will also slow you down a little.If you know the structure of the objects you are trying to clone or can avoid deep nested arrays you can write a simple for (var i in obj) loop to clone your object while checking hasOwnProperty and it will be much much faster than jQuery.Lastly if you are attempting to clone a known object structure in a hot loop you can get MUCH MUCH MORE PERFORMANCE by simply in-lining the clone procedure and manually constructing the object.JavaScript trace engines suck at optimizing for..in loops and checking hasOwnProperty will slow you down as well. Manual clone when speed is an absolute must.Beware using the JSON.parse(JSON.stringify(obj)) method on Date objects - JSON.stringify(new Date()) returns a string representation of the date in ISO format, which JSON.parse() doesn\'t convert back to a Date object. See this answer for more details.Assuming that you have only variables and not any functions in your object, you can  just use:If there wasn\'t any builtin one, you could try:HTML5 defines a method for creating deep clones of objects. It only works for certain built-in types, but is considerably more flexible than using JSON. The internal structured cloning algorithm also supports an increasing number of types including Dates, RegExps, Maps, Sets, Blobs, FileLists, ImageDatas, sparse Arrays, and Typed Arrays, and supports cyclical/recursive structures.There\'s no public API specifically for creating structured clones, but posting messages through MessageChannels is a pretty direct approach for asynchronous cloning. Here\'s one possible ES6 structuredClone(obj) function returning a Promise with a structured clone of obj.Unfortunately, there are no good options for creating structured clones synchronously. The idea of adding a built-in structuredClone(...) function has been discussed several times and proposed here, but no browser vendors have taken action. Here are a couple of impractical hacks instead.history.pushState() and history.replaceState() both create a structured clone of their first argument, and assign that value to history.state. You can use this to create a structured clone of any object like this:Though synchronous, this can be extremely slow. It incurs all of the overhead associated with manipulating the browser history. Calling this method repeatedly can cause Chrome to become temporarily unresponsive.The Notification constructor creates a structured clone of its associated data. It also attempts to display a browser notification to the user, but this will silently fail unless you have requested notification permission. In case you have the permission for other purposes, we\'ll immediately close the notification we\'ve created.An Object.assign method is part of the ECMAScript 2015 (ES6) standard and does exactly what you need.The Object.assign() method is used to copy the values of all enumerable own properties from one or more source objects to a target object.Read more...The polyfill to support older browsers:Code:Test:This is what I\'m using:Deep copy by performance:\nRanked from best to worstDeep copy an array of strings or numbers (one level - no reference pointers):When an array contains numbers and strings - functions like .slice(), .concat(), .splice(), the assignment operator "=", and Underscore.js\'s clone function; will make a deep copy of the array\'s elements.Where reassignment has the fastest performance:And .slice() has better performance than .concat(),\nhttp://jsperf.com/duplicate-array-slice-vs-concat/3Deep copy an array of objects (two or more levels - reference pointers):Write a custom function (has faster performance than $.extend() or JSON.parse):Use third-party utility functions:Where jQuery\'s $.extend has better performance:I know this is an old post, but I thought this may be of some help to the next person who stumbles along.As long as you don\'t assign an object to anything it maintains no reference in memory.  So to make an object that you want to share among other objects, you\'ll have to create a factory like so:There\xe2\x80\x99s a library (called \xe2\x80\x9cclone\xe2\x80\x9d), that does this quite well. It provides the most complete recursive cloning/copying of arbitrary objects that I know of. It also supports circular references, which is not covered by the other answers, yet.You can find it on npm, too. It can be used for the browser as well as Node.js.Here is an example on how to use it:Install it withor package it with Ender.You can also download the source code manually.Then you can use it in your source code.(Disclaimer: I\xe2\x80\x99m the author of the library.)If you\'re using it, the Underscore.js library has a clone method.The following creates two instances of the same object. I found it and am using it currently. It\'s simple and easy to use.Here\'s a version of ConroyP\'s answer above that works even if the constructor has required parameters:This function is also available in my simpleoo library.Edit:Here\'s a more robust version (thanks to Justin McCandless this now supports cyclic references as well):Deep cloning an Object was always a concern in JS, but it was all about before ES6, I list different ways of deep copying an object in JavaScript below, imagine you have the Object below and would like to have a deep copy of that:There are few ways to copy this object, without changing the origin:1) ES6, all modern browsers supporting ES6, but if you browser not, you can use BabelJs, deep copy of an object is very easy in ES6:2) ES5+, Using a simple function to do the copy for you:3) ES5+, using JSON.parse and JSON.stringify, Not a recommended way, it\'s quick, but in clean code way, it\'s not the best solution: 4) AngularJs: 5) jQuery: 6) UnderscoreJs & Loadash: Hope these help... Crockford suggests (and I prefer) using this function:It\'s terse, works as expected and you don\'t need a library.EDIT:This is a polyfill for Object.create, so you also can use this.NOTE:  If you use some of this, you may have problems with some iteration who use hasOwnProperty. Because, create create new empty object who inherits oldObject. But it is still useful and practical for cloning objects.For exemple if  oldObject.a = 5;but:Shallow copy one-liner (ECMAScript 5th edition):And shallow copy one-liner (ECMAScript 6th edition, 2015):There seems to be no ideal deep clone operator yet for array-like objects.  As the code below illustrates, John Resig\'s jQuery cloner turns arrays with non-numeric properties into objects that are not arrays, and RegDwight\'s JSON cloner drops the non-numeric properties. The following tests illustrate these points on multiple browsers:Lodash has a nice _.cloneDeep method: http://lodash.com/docs#cloneDeepThe usual _.clone method also accepts a second parameter to make a deep copy instead of the shallow one: http://lodash.com/docs#cloneI have two good answers depending on whether your objective is to clone a "plain old JavaScript object" or not.Let\'s also assume that your intention is to create a complete clone with no prototype references back to the source object. If you\'re not interested in a complete clone, then you can use many of the Object.clone() routines provided in some of the other answers (Crockford\'s pattern).For plain old JavaScript objects, a tried and true good way to clone an object in modern runtimes is quite simply:Note that the source object must be a pure JSON object. This is to say, all of its nested properties must be scalars (like boolean, string, array, object, etc). Any functions or special objects like RegExp or Date will not be cloned.Is it efficient? Heck yes. We\'ve tried all kinds of cloning methods and this works best. I\'m sure some ninja could conjure up a faster method. But I suspect we\'re talking about marginal gains.This approach is just simple and easy to implement. Wrap it into a convenience function and if you really need to squeeze out some gain, go for at a later time.Now, for non-plain JavaScript objects, there isn\'t a really simple answer.  In fact, there can\'t be because of the dynamic nature of JavaScript functions and inner object state. Deep cloning a JSON structure with functions inside requires you recreate those functions and their inner context. And JavaScript simply doesn\'t have a standardized way of doing that.The correct way to do this, once again, is via a convenience method that you declare and reuse within your code. The convenience method can be endowed with some understanding of your own objects so you can make sure to properly recreate the graph within the new object.We\'re written our own, but the best general approach I\'ve seen is covered here:http://davidwalsh.name/javascript-cloneThis is the right idea. The author (David Walsh) has commented out the cloning of generalized functions. This is something you might choose to do, depending on your use case.The main idea is that you need to special handle the instantiation of your functions (or prototypal classes, so to speak) on a per-type basis. Here, he\'s provided a few examples for RegExp and Date.Not only is this code brief, but it\'s also very readable. It\'s pretty easy to extend.Is this efficient? Heck yes. Given that the goal is to produce a true deep-copy clone, then you\'re going to have to walk the members of the source object graph. With this approach, you can tweak exactly which child members to treat and how to manually handle custom types.So there you go. Two approaches. Both are efficient in my view.Just because I didn\'t see AngularJS mentioned and thought that people might want to know...angular.copy also provides a method of deep copying objects and arrays.This isn\'t generally the most efficient solution, but it does what I need. Simple test cases below...Cyclic array test...Function test...Cloning an object using today\'s JavaScript: ECMAScript 2015 (formerly known as ECMAScriptÂ 6)Old browsers may not support ECMAScript 2015. A common solution is to use a JavaScript-to-JavaScript compiler like Babel to output an ECMAScript 5 version of your JavaScript code.As pointed out by @jim-hall, this is only a shallow copy. Properties of properties are copied as a reference: changing one would change the value in the other object/instance.Well if you\'re using angular you could do this tooFor future reference, the current draft of ECMAScript 6 introduces Object.assign as a way of cloning objects. Example code would be:At the time of writing support is limited to Firefox 34 in browsers so it\xe2\x80\x99s not usable in production code just yet (unless you\xe2\x80\x99re writing a Firefox extension of course).// obj target object, vals source objectI usually use var newObj = JSON.parse( JSON.stringify(oldObje) ); but, here\'s a more proper way:Watch legacy browsers!Here is a comprehensive clone() method that can clone any JavaScript object. It handles almost all the cases: